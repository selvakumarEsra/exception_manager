(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global.UniversalRouter = global.UniversalRouter || {})));
}(this, function (exports) { 'use strict';

  var __commonjs_global = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : this;
  function __commonjs(fn, module) { return module = { exports: {} }, fn(module, module.exports, __commonjs_global), module.exports; }

  var _core = __commonjs(function (module) {
  var core = module.exports = {version: '2.4.0'};
  if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef
  });

  var require$$0$3 = (_core && typeof _core === 'object' && 'default' in _core ? _core['default'] : _core);

  var _fails = __commonjs(function (module) {
  module.exports = function(exec){
    try {
      return !!exec();
    } catch(e){
      return true;
    }
  };
  });

  var require$$9 = (_fails && typeof _fails === 'object' && 'default' in _fails ? _fails['default'] : _fails);

  var _descriptors = __commonjs(function (module) {
  // Thank's IE8 for his funny defineProperty
  module.exports = !require$$9(function(){
    return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
  });
  });

  var require$$1 = (_descriptors && typeof _descriptors === 'object' && 'default' in _descriptors ? _descriptors['default'] : _descriptors);

  var _isObject = __commonjs(function (module) {
  module.exports = function(it){
    return typeof it === 'object' ? it !== null : typeof it === 'function';
  };
  });

  var require$$2 = (_isObject && typeof _isObject === 'object' && 'default' in _isObject ? _isObject['default'] : _isObject);

  var _toPrimitive = __commonjs(function (module) {
  // 7.1.1 ToPrimitive(input [, PreferredType])
  var isObject = require$$2;
  // instead of the ES6 spec version, we didn't implement @@toPrimitive case
  // and the second argument - flag - preferred type is a string
  module.exports = function(it, S){
    if(!isObject(it))return it;
    var fn, val;
    if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
    if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
    if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
    throw TypeError("Can't convert object to primitive value");
  };
  });

  var require$$3 = (_toPrimitive && typeof _toPrimitive === 'object' && 'default' in _toPrimitive ? _toPrimitive['default'] : _toPrimitive);

  var _global = __commonjs(function (module) {
  // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
  var global = module.exports = typeof window != 'undefined' && window.Math == Math
    ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
  if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef
  });

  var require$$12$1 = (_global && typeof _global === 'object' && 'default' in _global ? _global['default'] : _global);

  var _domCreate = __commonjs(function (module) {
  var isObject = require$$2
    , document = require$$12$1.document
    // in old IE typeof document.createElement is 'object'
    , is = isObject(document) && isObject(document.createElement);
  module.exports = function(it){
    return is ? document.createElement(it) : {};
  };
  });

  var require$$2$1 = (_domCreate && typeof _domCreate === 'object' && 'default' in _domCreate ? _domCreate['default'] : _domCreate);

  var _ie8DomDefine = __commonjs(function (module) {
  module.exports = !require$$1 && !require$$9(function(){
    return Object.defineProperty(require$$2$1('div'), 'a', {get: function(){ return 7; }}).a != 7;
  });
  });

  var require$$1$1 = (_ie8DomDefine && typeof _ie8DomDefine === 'object' && 'default' in _ie8DomDefine ? _ie8DomDefine['default'] : _ie8DomDefine);

  var _anObject = __commonjs(function (module) {
  var isObject = require$$2;
  module.exports = function(it){
    if(!isObject(it))throw TypeError(it + ' is not an object!');
    return it;
  };
  });

  var require$$2$2 = (_anObject && typeof _anObject === 'object' && 'default' in _anObject ? _anObject['default'] : _anObject);

  var _objectDp = __commonjs(function (module, exports) {
  var anObject       = require$$2$2
    , IE8_DOM_DEFINE = require$$1$1
    , toPrimitive    = require$$3
    , dP             = Object.defineProperty;

  exports.f = require$$1 ? Object.defineProperty : function defineProperty(O, P, Attributes){
    anObject(O);
    P = toPrimitive(P, true);
    anObject(Attributes);
    if(IE8_DOM_DEFINE)try {
      return dP(O, P, Attributes);
    } catch(e){ /* empty */ }
    if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
    if('value' in Attributes)O[P] = Attributes.value;
    return O;
  };
  });

  var require$$12 = (_objectDp && typeof _objectDp === 'object' && 'default' in _objectDp ? _objectDp['default'] : _objectDp);

  var _uid = __commonjs(function (module) {
  var id = 0
    , px = Math.random();
  module.exports = function(key){
    return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
  };
  });

  var require$$4 = (_uid && typeof _uid === 'object' && 'default' in _uid ? _uid['default'] : _uid);

  var _shared = __commonjs(function (module) {
  var global = require$$12$1
    , SHARED = '__core-js_shared__'
    , store  = global[SHARED] || (global[SHARED] = {});
  module.exports = function(key){
    return store[key] || (store[key] = {});
  };
  });

  var require$$1$2 = (_shared && typeof _shared === 'object' && 'default' in _shared ? _shared['default'] : _shared);

  var _wks = __commonjs(function (module) {
  var store      = require$$1$2('wks')
    , uid        = require$$4
    , Symbol     = require$$12$1.Symbol
    , USE_SYMBOL = typeof Symbol == 'function';

  var $exports = module.exports = function(name){
    return store[name] || (store[name] =
      USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
  };

  $exports.store = store;
  });

  var require$$0$5 = (_wks && typeof _wks === 'object' && 'default' in _wks ? _wks['default'] : _wks);

  var _wksExt = __commonjs(function (module, exports) {
  exports.f = require$$0$5;
  });

  var require$$0$4 = (_wksExt && typeof _wksExt === 'object' && 'default' in _wksExt ? _wksExt['default'] : _wksExt);

  var _library = __commonjs(function (module) {
  module.exports = true;
  });

  var require$$19 = (_library && typeof _library === 'object' && 'default' in _library ? _library['default'] : _library);

  var _wksDefine = __commonjs(function (module) {
  var global         = require$$12$1
    , core           = require$$0$3
    , LIBRARY        = require$$19
    , wksExt         = require$$0$4
    , defineProperty = require$$12.f;
  module.exports = function(name){
    var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
    if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: wksExt.f(name)});
  };
  });

  var require$$17 = (_wksDefine && typeof _wksDefine === 'object' && 'default' in _wksDefine ? _wksDefine['default'] : _wksDefine);

  var es7_symbol_observable = __commonjs(function (module) {
  require$$17('observable');
  });

  var es7_symbol_asyncIterator = __commonjs(function (module) {
  require$$17('asyncIterator');
  });

  var _propertyDesc = __commonjs(function (module) {
  module.exports = function(bitmap, value){
    return {
      enumerable  : !(bitmap & 1),
      configurable: !(bitmap & 2),
      writable    : !(bitmap & 4),
      value       : value
    };
  };
  });

  var require$$3$1 = (_propertyDesc && typeof _propertyDesc === 'object' && 'default' in _propertyDesc ? _propertyDesc['default'] : _propertyDesc);

  var _hide = __commonjs(function (module) {
  var dP         = require$$12
    , createDesc = require$$3$1;
  module.exports = require$$1 ? function(object, key, value){
    return dP.f(object, key, createDesc(1, value));
  } : function(object, key, value){
    object[key] = value;
    return object;
  };
  });

  var require$$10 = (_hide && typeof _hide === 'object' && 'default' in _hide ? _hide['default'] : _hide);

  var _objectGops = __commonjs(function (module, exports) {
  exports.f = Object.getOwnPropertySymbols;
  });

  var require$$4$1 = (_objectGops && typeof _objectGops === 'object' && 'default' in _objectGops ? _objectGops['default'] : _objectGops);

  var _objectPie = __commonjs(function (module, exports) {
  exports.f = {}.propertyIsEnumerable;
  });

  var require$$3$2 = (_objectPie && typeof _objectPie === 'object' && 'default' in _objectPie ? _objectPie['default'] : _objectPie);

  var _enumBugKeys = __commonjs(function (module) {
  // IE 8- don't enum bug keys
  module.exports = (
    'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
  ).split(',');
  });

  var require$$3$3 = (_enumBugKeys && typeof _enumBugKeys === 'object' && 'default' in _enumBugKeys ? _enumBugKeys['default'] : _enumBugKeys);

  var _sharedKey = __commonjs(function (module) {
  var shared = require$$1$2('keys')
    , uid    = require$$4;
  module.exports = function(key){
    return shared[key] || (shared[key] = uid(key));
  };
  });

  var require$$0$7 = (_sharedKey && typeof _sharedKey === 'object' && 'default' in _sharedKey ? _sharedKey['default'] : _sharedKey);

  var _toInteger = __commonjs(function (module) {
  // 7.1.4 ToInteger
  var ceil  = Math.ceil
    , floor = Math.floor;
  module.exports = function(it){
    return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
  };
  });

  var require$$1$5 = (_toInteger && typeof _toInteger === 'object' && 'default' in _toInteger ? _toInteger['default'] : _toInteger);

  var _toIndex = __commonjs(function (module) {
  var toInteger = require$$1$5
    , max       = Math.max
    , min       = Math.min;
  module.exports = function(index, length){
    index = toInteger(index);
    return index < 0 ? max(index + length, 0) : min(index, length);
  };
  });

  var require$$0$8 = (_toIndex && typeof _toIndex === 'object' && 'default' in _toIndex ? _toIndex['default'] : _toIndex);

  var _toLength = __commonjs(function (module) {
  // 7.1.15 ToLength
  var toInteger = require$$1$5
    , min       = Math.min;
  module.exports = function(it){
    return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
  };
  });

  var require$$1$6 = (_toLength && typeof _toLength === 'object' && 'default' in _toLength ? _toLength['default'] : _toLength);

  var _defined = __commonjs(function (module) {
  // 7.2.1 RequireObjectCoercible(argument)
  module.exports = function(it){
    if(it == undefined)throw TypeError("Can't call method on  " + it);
    return it;
  };
  });

  var require$$6 = (_defined && typeof _defined === 'object' && 'default' in _defined ? _defined['default'] : _defined);

  var _cof = __commonjs(function (module) {
  var toString = {}.toString;

  module.exports = function(it){
    return toString.call(it).slice(8, -1);
  };
  });

  var require$$1$8 = (_cof && typeof _cof === 'object' && 'default' in _cof ? _cof['default'] : _cof);

  var _iobject = __commonjs(function (module) {
  // fallback for non-array-like ES3 and non-enumerable old V8 strings
  var cof = require$$1$8;
  module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
    return cof(it) == 'String' ? it.split('') : Object(it);
  };
  });

  var require$$3$4 = (_iobject && typeof _iobject === 'object' && 'default' in _iobject ? _iobject['default'] : _iobject);

  var _toIobject = __commonjs(function (module) {
  // to indexed object, toObject with fallback for non-array-like ES3 strings
  var IObject = require$$3$4
    , defined = require$$6;
  module.exports = function(it){
    return IObject(defined(it));
  };
  });

  var require$$1$7 = (_toIobject && typeof _toIobject === 'object' && 'default' in _toIobject ? _toIobject['default'] : _toIobject);

  var _arrayIncludes = __commonjs(function (module) {
  // false -> Array#indexOf
  // true  -> Array#includes
  var toIObject = require$$1$7
    , toLength  = require$$1$6
    , toIndex   = require$$0$8;
  module.exports = function(IS_INCLUDES){
    return function($this, el, fromIndex){
      var O      = toIObject($this)
        , length = toLength(O.length)
        , index  = toIndex(fromIndex, length)
        , value;
      // Array#includes uses SameValueZero equality algorithm
      if(IS_INCLUDES && el != el)while(length > index){
        value = O[index++];
        if(value != value)return true;
      // Array#toIndex ignores holes, Array#includes - not
      } else for(;length > index; index++)if(IS_INCLUDES || index in O){
        if(O[index] === el)return IS_INCLUDES || index || 0;
      } return !IS_INCLUDES && -1;
    };
  };
  });

  var require$$1$4 = (_arrayIncludes && typeof _arrayIncludes === 'object' && 'default' in _arrayIncludes ? _arrayIncludes['default'] : _arrayIncludes);

  var _has = __commonjs(function (module) {
  var hasOwnProperty = {}.hasOwnProperty;
  module.exports = function(it, key){
    return hasOwnProperty.call(it, key);
  };
  });

  var require$$2$3 = (_has && typeof _has === 'object' && 'default' in _has ? _has['default'] : _has);

  var _objectKeysInternal = __commonjs(function (module) {
  var has          = require$$2$3
    , toIObject    = require$$1$7
    , arrayIndexOf = require$$1$4(false)
    , IE_PROTO     = require$$0$7('IE_PROTO');

  module.exports = function(object, names){
    var O      = toIObject(object)
      , i      = 0
      , result = []
      , key;
    for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
    // Don't enum bug & hidden keys
    while(names.length > i)if(has(O, key = names[i++])){
      ~arrayIndexOf(result, key) || result.push(key);
    }
    return result;
  };
  });

  var require$$1$3 = (_objectKeysInternal && typeof _objectKeysInternal === 'object' && 'default' in _objectKeysInternal ? _objectKeysInternal['default'] : _objectKeysInternal);

  var _objectGopn = __commonjs(function (module, exports) {
  // 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
  var $keys      = require$$1$3
    , hiddenKeys = require$$3$3.concat('length', 'prototype');

  exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){
    return $keys(O, hiddenKeys);
  };
  });

  var require$$0$6 = (_objectGopn && typeof _objectGopn === 'object' && 'default' in _objectGopn ? _objectGopn['default'] : _objectGopn);

  var _objectKeys = __commonjs(function (module) {
  // 19.1.2.14 / 15.2.3.14 Object.keys(O)
  var $keys       = require$$1$3
    , enumBugKeys = require$$3$3;

  module.exports = Object.keys || function keys(O){
    return $keys(O, enumBugKeys);
  };
  });

  var require$$5 = (_objectKeys && typeof _objectKeys === 'object' && 'default' in _objectKeys ? _objectKeys['default'] : _objectKeys);

  var _objectGopd = __commonjs(function (module, exports) {
  var pIE            = require$$3$2
    , createDesc     = require$$3$1
    , toIObject      = require$$1$7
    , toPrimitive    = require$$3
    , has            = require$$2$3
    , IE8_DOM_DEFINE = require$$1$1
    , gOPD           = Object.getOwnPropertyDescriptor;

  exports.f = require$$1 ? gOPD : function getOwnPropertyDescriptor(O, P){
    O = toIObject(O);
    P = toPrimitive(P, true);
    if(IE8_DOM_DEFINE)try {
      return gOPD(O, P);
    } catch(e){ /* empty */ }
    if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);
  };
  });

  var require$$0$9 = (_objectGopd && typeof _objectGopd === 'object' && 'default' in _objectGopd ? _objectGopd['default'] : _objectGopd);

  var _objectGopnExt = __commonjs(function (module) {
  // fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
  var toIObject = require$$1$7
    , gOPN      = require$$0$6.f
    , toString  = {}.toString;

  var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
    ? Object.getOwnPropertyNames(window) : [];

  var getWindowNames = function(it){
    try {
      return gOPN(it);
    } catch(e){
      return windowNames.slice();
    }
  };

  module.exports.f = function getOwnPropertyNames(it){
    return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
  };
  });

  var require$$8 = (_objectGopnExt && typeof _objectGopnExt === 'object' && 'default' in _objectGopnExt ? _objectGopnExt['default'] : _objectGopnExt);

  var _html = __commonjs(function (module) {
  module.exports = require$$12$1.document && document.documentElement;
  });

  var require$$3$5 = (_html && typeof _html === 'object' && 'default' in _html ? _html['default'] : _html);

  var _objectDps = __commonjs(function (module) {
  var dP       = require$$12
    , anObject = require$$2$2
    , getKeys  = require$$5;

  module.exports = require$$1 ? Object.defineProperties : function defineProperties(O, Properties){
    anObject(O);
    var keys   = getKeys(Properties)
      , length = keys.length
      , i = 0
      , P;
    while(length > i)dP.f(O, P = keys[i++], Properties[P]);
    return O;
  };
  });

  var require$$4$2 = (_objectDps && typeof _objectDps === 'object' && 'default' in _objectDps ? _objectDps['default'] : _objectDps);

  var _objectCreate = __commonjs(function (module) {
  // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
  var anObject    = require$$2$2
    , dPs         = require$$4$2
    , enumBugKeys = require$$3$3
    , IE_PROTO    = require$$0$7('IE_PROTO')
    , Empty       = function(){ /* empty */ }
    , PROTOTYPE   = 'prototype';

  // Create object with fake `null` prototype: use iframe Object with cleared prototype
  var createDict = function(){
    // Thrash, waste and sodomy: IE GC bug
    var iframe = require$$2$1('iframe')
      , i      = enumBugKeys.length
      , gt     = '>'
      , iframeDocument;
    iframe.style.display = 'none';
    require$$3$5.appendChild(iframe);
    iframe.src = 'javascript:'; // eslint-disable-line no-script-url
    // createDict = iframe.contentWindow.Object;
    // html.removeChild(iframe);
    iframeDocument = iframe.contentWindow.document;
    iframeDocument.open();
    iframeDocument.write('<script>document.F=Object</script' + gt);
    iframeDocument.close();
    createDict = iframeDocument.F;
    while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];
    return createDict();
  };

  module.exports = Object.create || function create(O, Properties){
    var result;
    if(O !== null){
      Empty[PROTOTYPE] = anObject(O);
      result = new Empty;
      Empty[PROTOTYPE] = null;
      // add "__proto__" for Object.getPrototypeOf polyfill
      result[IE_PROTO] = O;
    } else result = createDict();
    return Properties === undefined ? result : dPs(result, Properties);
  };
  });

  var require$$11 = (_objectCreate && typeof _objectCreate === 'object' && 'default' in _objectCreate ? _objectCreate['default'] : _objectCreate);

  var _isArray = __commonjs(function (module) {
  // 7.2.2 IsArray(argument)
  var cof = require$$1$8;
  module.exports = Array.isArray || function isArray(arg){
    return cof(arg) == 'Array';
  };
  });

  var require$$1$9 = (_isArray && typeof _isArray === 'object' && 'default' in _isArray ? _isArray['default'] : _isArray);

  var _enumKeys = __commonjs(function (module) {
  // all enumerable object keys, includes symbols
  var getKeys = require$$5
    , gOPS    = require$$4$1
    , pIE     = require$$3$2;
  module.exports = function(it){
    var result     = getKeys(it)
      , getSymbols = gOPS.f;
    if(getSymbols){
      var symbols = getSymbols(it)
        , isEnum  = pIE.f
        , i       = 0
        , key;
      while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);
    } return result;
  };
  });

  var require$$15 = (_enumKeys && typeof _enumKeys === 'object' && 'default' in _enumKeys ? _enumKeys['default'] : _enumKeys);

  var _keyof = __commonjs(function (module) {
  var getKeys   = require$$5
    , toIObject = require$$1$7;
  module.exports = function(object, el){
    var O      = toIObject(object)
      , keys   = getKeys(O)
      , length = keys.length
      , index  = 0
      , key;
    while(length > index)if(O[key = keys[index++]] === el)return key;
  };
  });

  var require$$16 = (_keyof && typeof _keyof === 'object' && 'default' in _keyof ? _keyof['default'] : _keyof);

  var _setToStringTag = __commonjs(function (module) {
  var def = require$$12.f
    , has = require$$2$3
    , TAG = require$$0$5('toStringTag');

  module.exports = function(it, tag, stat){
    if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
  };
  });

  var require$$3$6 = (_setToStringTag && typeof _setToStringTag === 'object' && 'default' in _setToStringTag ? _setToStringTag['default'] : _setToStringTag);

  var _meta = __commonjs(function (module) {
  var META     = require$$4('meta')
    , isObject = require$$2
    , has      = require$$2$3
    , setDesc  = require$$12.f
    , id       = 0;
  var isExtensible = Object.isExtensible || function(){
    return true;
  };
  var FREEZE = !require$$9(function(){
    return isExtensible(Object.preventExtensions({}));
  });
  var setMeta = function(it){
    setDesc(it, META, {value: {
      i: 'O' + ++id, // object ID
      w: {}          // weak collections IDs
    }});
  };
  var fastKey = function(it, create){
    // return primitive with prefix
    if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
    if(!has(it, META)){
      // can't set metadata to uncaught frozen object
      if(!isExtensible(it))return 'F';
      // not necessary to add metadata
      if(!create)return 'E';
      // add missing metadata
      setMeta(it);
    // return object ID
    } return it[META].i;
  };
  var getWeak = function(it, create){
    if(!has(it, META)){
      // can't set metadata to uncaught frozen object
      if(!isExtensible(it))return true;
      // not necessary to add metadata
      if(!create)return false;
      // add missing metadata
      setMeta(it);
    // return hash weak collections IDs
    } return it[META].w;
  };
  // add metadata on freeze-family methods calling
  var onFreeze = function(it){
    if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);
    return it;
  };
  var meta = module.exports = {
    KEY:      META,
    NEED:     false,
    fastKey:  fastKey,
    getWeak:  getWeak,
    onFreeze: onFreeze
  };
  });

  var require$$0$10 = (_meta && typeof _meta === 'object' && 'default' in _meta ? _meta['default'] : _meta);

  var _redefine = __commonjs(function (module) {
  module.exports = require$$10;
  });

  var require$$7 = (_redefine && typeof _redefine === 'object' && 'default' in _redefine ? _redefine['default'] : _redefine);

  var _aFunction = __commonjs(function (module) {
  module.exports = function(it){
    if(typeof it != 'function')throw TypeError(it + ' is not a function!');
    return it;
  };
  });

  var require$$1$10 = (_aFunction && typeof _aFunction === 'object' && 'default' in _aFunction ? _aFunction['default'] : _aFunction);

  var _ctx = __commonjs(function (module) {
  // optional / simple context binding
  var aFunction = require$$1$10;
  module.exports = function(fn, that, length){
    aFunction(fn);
    if(that === undefined)return fn;
    switch(length){
      case 1: return function(a){
        return fn.call(that, a);
      };
      case 2: return function(a, b){
        return fn.call(that, a, b);
      };
      case 3: return function(a, b, c){
        return fn.call(that, a, b, c);
      };
    }
    return function(/* ...args */){
      return fn.apply(that, arguments);
    };
  };
  });

  var require$$8$1 = (_ctx && typeof _ctx === 'object' && 'default' in _ctx ? _ctx['default'] : _ctx);

  var _export = __commonjs(function (module, exports) {
  var global    = require$$12$1
    , core      = require$$0$3
    , ctx       = require$$8$1
    , hide      = require$$10
    , PROTOTYPE = 'prototype';

  var $export = function(type, name, source){
    var IS_FORCED = type & $export.F
      , IS_GLOBAL = type & $export.G
      , IS_STATIC = type & $export.S
      , IS_PROTO  = type & $export.P
      , IS_BIND   = type & $export.B
      , IS_WRAP   = type & $export.W
      , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
      , expProto  = exports[PROTOTYPE]
      , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]
      , key, own, out;
    if(IS_GLOBAL)source = name;
    for(key in source){
      // contains in native
      own = !IS_FORCED && target && target[key] !== undefined;
      if(own && key in exports)continue;
      // export native or passed
      out = own ? target[key] : source[key];
      // prevent global pollution for namespaces
      exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
      // bind timers to global for call from export context
      : IS_BIND && own ? ctx(out, global)
      // wrap global constructors for prevent change them in library
      : IS_WRAP && target[key] == out ? (function(C){
        var F = function(a, b, c){
          if(this instanceof C){
            switch(arguments.length){
              case 0: return new C;
              case 1: return new C(a);
              case 2: return new C(a, b);
            } return new C(a, b, c);
          } return C.apply(this, arguments);
        };
        F[PROTOTYPE] = C[PROTOTYPE];
        return F;
      // make static versions for prototype methods
      })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
      // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
      if(IS_PROTO){
        (exports.virtual || (exports.virtual = {}))[key] = out;
        // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
        if(type & $export.R && expProto && !expProto[key])hide(expProto, key, out);
      }
    }
  };
  // type bitmap
  $export.F = 1;   // forced
  $export.G = 2;   // global
  $export.S = 4;   // static
  $export.P = 8;   // proto
  $export.B = 16;  // bind
  $export.W = 32;  // wrap
  $export.U = 64;  // safe
  $export.R = 128; // real proto method for `library` 
  module.exports = $export;
  });

  var require$$11$1 = (_export && typeof _export === 'object' && 'default' in _export ? _export['default'] : _export);

  var es6_symbol = __commonjs(function (module) {
  'use strict';
  // ECMAScript 6 symbols shim
  var global         = require$$12$1
    , has            = require$$2$3
    , DESCRIPTORS    = require$$1
    , $export        = require$$11$1
    , redefine       = require$$7
    , META           = require$$0$10.KEY
    , $fails         = require$$9
    , shared         = require$$1$2
    , setToStringTag = require$$3$6
    , uid            = require$$4
    , wks            = require$$0$5
    , wksExt         = require$$0$4
    , wksDefine      = require$$17
    , keyOf          = require$$16
    , enumKeys       = require$$15
    , isArray        = require$$1$9
    , anObject       = require$$2$2
    , toIObject      = require$$1$7
    , toPrimitive    = require$$3
    , createDesc     = require$$3$1
    , _create        = require$$11
    , gOPNExt        = require$$8
    , $GOPD          = require$$0$9
    , $DP            = require$$12
    , $keys          = require$$5
    , gOPD           = $GOPD.f
    , dP             = $DP.f
    , gOPN           = gOPNExt.f
    , $Symbol        = global.Symbol
    , $JSON          = global.JSON
    , _stringify     = $JSON && $JSON.stringify
    , PROTOTYPE      = 'prototype'
    , HIDDEN         = wks('_hidden')
    , TO_PRIMITIVE   = wks('toPrimitive')
    , isEnum         = {}.propertyIsEnumerable
    , SymbolRegistry = shared('symbol-registry')
    , AllSymbols     = shared('symbols')
    , OPSymbols      = shared('op-symbols')
    , ObjectProto    = Object[PROTOTYPE]
    , USE_NATIVE     = typeof $Symbol == 'function'
    , QObject        = global.QObject;
  // Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
  var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

  // fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
  var setSymbolDesc = DESCRIPTORS && $fails(function(){
    return _create(dP({}, 'a', {
      get: function(){ return dP(this, 'a', {value: 7}).a; }
    })).a != 7;
  }) ? function(it, key, D){
    var protoDesc = gOPD(ObjectProto, key);
    if(protoDesc)delete ObjectProto[key];
    dP(it, key, D);
    if(protoDesc && it !== ObjectProto)dP(ObjectProto, key, protoDesc);
  } : dP;

  var wrap = function(tag){
    var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
    sym._k = tag;
    return sym;
  };

  var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){
    return typeof it == 'symbol';
  } : function(it){
    return it instanceof $Symbol;
  };

  var $defineProperty = function defineProperty(it, key, D){
    if(it === ObjectProto)$defineProperty(OPSymbols, key, D);
    anObject(it);
    key = toPrimitive(key, true);
    anObject(D);
    if(has(AllSymbols, key)){
      if(!D.enumerable){
        if(!has(it, HIDDEN))dP(it, HIDDEN, createDesc(1, {}));
        it[HIDDEN][key] = true;
      } else {
        if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
        D = _create(D, {enumerable: createDesc(0, false)});
      } return setSymbolDesc(it, key, D);
    } return dP(it, key, D);
  };
  var $defineProperties = function defineProperties(it, P){
    anObject(it);
    var keys = enumKeys(P = toIObject(P))
      , i    = 0
      , l = keys.length
      , key;
    while(l > i)$defineProperty(it, key = keys[i++], P[key]);
    return it;
  };
  var $create = function create(it, P){
    return P === undefined ? _create(it) : $defineProperties(_create(it), P);
  };
  var $propertyIsEnumerable = function propertyIsEnumerable(key){
    var E = isEnum.call(this, key = toPrimitive(key, true));
    if(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return false;
    return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
  };
  var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
    it  = toIObject(it);
    key = toPrimitive(key, true);
    if(it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return;
    var D = gOPD(it, key);
    if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
    return D;
  };
  var $getOwnPropertyNames = function getOwnPropertyNames(it){
    var names  = gOPN(toIObject(it))
      , result = []
      , i      = 0
      , key;
    while(names.length > i){
      if(!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);
    } return result;
  };
  var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
    var IS_OP  = it === ObjectProto
      , names  = gOPN(IS_OP ? OPSymbols : toIObject(it))
      , result = []
      , i      = 0
      , key;
    while(names.length > i){
      if(has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))result.push(AllSymbols[key]);
    } return result;
  };

  // 19.4.1.1 Symbol([description])
  if(!USE_NATIVE){
    $Symbol = function Symbol(){
      if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');
      var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
      var $set = function(value){
        if(this === ObjectProto)$set.call(OPSymbols, value);
        if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
        setSymbolDesc(this, tag, createDesc(1, value));
      };
      if(DESCRIPTORS && setter)setSymbolDesc(ObjectProto, tag, {configurable: true, set: $set});
      return wrap(tag);
    };
    redefine($Symbol[PROTOTYPE], 'toString', function toString(){
      return this._k;
    });

    $GOPD.f = $getOwnPropertyDescriptor;
    $DP.f   = $defineProperty;
    require$$0$6.f = gOPNExt.f = $getOwnPropertyNames;
    require$$3$2.f  = $propertyIsEnumerable;
    require$$4$1.f = $getOwnPropertySymbols;

    if(DESCRIPTORS && !require$$19){
      redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
    }

    wksExt.f = function(name){
      return wrap(wks(name));
    }
  }

  $export($export.G + $export.W + $export.F * !USE_NATIVE, {Symbol: $Symbol});

  for(var symbols = (
    // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
    'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
  ).split(','), i = 0; symbols.length > i; )wks(symbols[i++]);

  for(var symbols = $keys(wks.store), i = 0; symbols.length > i; )wksDefine(symbols[i++]);

  $export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
    // 19.4.2.1 Symbol.for(key)
    'for': function(key){
      return has(SymbolRegistry, key += '')
        ? SymbolRegistry[key]
        : SymbolRegistry[key] = $Symbol(key);
    },
    // 19.4.2.5 Symbol.keyFor(sym)
    keyFor: function keyFor(key){
      if(isSymbol(key))return keyOf(SymbolRegistry, key);
      throw TypeError(key + ' is not a symbol!');
    },
    useSetter: function(){ setter = true; },
    useSimple: function(){ setter = false; }
  });

  $export($export.S + $export.F * !USE_NATIVE, 'Object', {
    // 19.1.2.2 Object.create(O [, Properties])
    create: $create,
    // 19.1.2.4 Object.defineProperty(O, P, Attributes)
    defineProperty: $defineProperty,
    // 19.1.2.3 Object.defineProperties(O, Properties)
    defineProperties: $defineProperties,
    // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
    getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
    // 19.1.2.7 Object.getOwnPropertyNames(O)
    getOwnPropertyNames: $getOwnPropertyNames,
    // 19.1.2.8 Object.getOwnPropertySymbols(O)
    getOwnPropertySymbols: $getOwnPropertySymbols
  });

  // 24.3.2 JSON.stringify(value [, replacer [, space]])
  $JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function(){
    var S = $Symbol();
    // MS Edge converts symbol values to JSON as {}
    // WebKit converts symbol values to JSON as null
    // V8 throws on boxed symbols
    return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
  })), 'JSON', {
    stringify: function stringify(it){
      if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined
      var args = [it]
        , i    = 1
        , replacer, $replacer;
      while(arguments.length > i)args.push(arguments[i++]);
      replacer = args[1];
      if(typeof replacer == 'function')$replacer = replacer;
      if($replacer || !isArray(replacer))replacer = function(key, value){
        if($replacer)value = $replacer.call(this, key, value);
        if(!isSymbol(value))return value;
      };
      args[1] = replacer;
      return _stringify.apply($JSON, args);
    }
  });

  // 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
  $Symbol[PROTOTYPE][TO_PRIMITIVE] || require$$10($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
  // 19.4.3.5 Symbol.prototype[@@toStringTag]
  setToStringTag($Symbol, 'Symbol');
  // 20.2.1.9 Math[@@toStringTag]
  setToStringTag(Math, 'Math', true);
  // 24.3.3 JSON[@@toStringTag]
  setToStringTag(global.JSON, 'JSON', true);
  });

  var index$1 = __commonjs(function (module) {
  module.exports = require$$0$3.Symbol;
  });

  var require$$0$2 = (index$1 && typeof index$1 === 'object' && 'default' in index$1 ? index$1['default'] : index$1);

  var symbol = __commonjs(function (module) {
  module.exports = { "default": require$$0$2, __esModule: true };
  });

  var require$$0$1 = (symbol && typeof symbol === 'object' && 'default' in symbol ? symbol['default'] : symbol);

  var _iterators = __commonjs(function (module) {
  module.exports = {};
  });

  var require$$1$12 = (_iterators && typeof _iterators === 'object' && 'default' in _iterators ? _iterators['default'] : _iterators);

  var _toObject = __commonjs(function (module) {
  // 7.1.13 ToObject(argument)
  var defined = require$$6;
  module.exports = function(it){
    return Object(defined(it));
  };
  });

  var require$$2$4 = (_toObject && typeof _toObject === 'object' && 'default' in _toObject ? _toObject['default'] : _toObject);

  var _objectGpo = __commonjs(function (module) {
  // 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
  var has         = require$$2$3
    , toObject    = require$$2$4
    , IE_PROTO    = require$$0$7('IE_PROTO')
    , ObjectProto = Object.prototype;

  module.exports = Object.getPrototypeOf || function(O){
    O = toObject(O);
    if(has(O, IE_PROTO))return O[IE_PROTO];
    if(typeof O.constructor == 'function' && O instanceof O.constructor){
      return O.constructor.prototype;
    } return O instanceof Object ? ObjectProto : null;
  };
  });

  var require$$1$13 = (_objectGpo && typeof _objectGpo === 'object' && 'default' in _objectGpo ? _objectGpo['default'] : _objectGpo);

  var _iterCreate = __commonjs(function (module) {
  'use strict';
  var create         = require$$11
    , descriptor     = require$$3$1
    , setToStringTag = require$$3$6
    , IteratorPrototype = {};

  // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
  require$$10(IteratorPrototype, require$$0$5('iterator'), function(){ return this; });

  module.exports = function(Constructor, NAME, next){
    Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});
    setToStringTag(Constructor, NAME + ' Iterator');
  };
  });

  var require$$3$7 = (_iterCreate && typeof _iterCreate === 'object' && 'default' in _iterCreate ? _iterCreate['default'] : _iterCreate);

  var _iterDefine = __commonjs(function (module) {
  'use strict';
  var LIBRARY        = require$$19
    , $export        = require$$11$1
    , redefine       = require$$7
    , hide           = require$$10
    , has            = require$$2$3
    , Iterators      = require$$1$12
    , $iterCreate    = require$$3$7
    , setToStringTag = require$$3$6
    , getPrototypeOf = require$$1$13
    , ITERATOR       = require$$0$5('iterator')
    , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
    , FF_ITERATOR    = '@@iterator'
    , KEYS           = 'keys'
    , VALUES         = 'values';

  var returnThis = function(){ return this; };

  module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){
    $iterCreate(Constructor, NAME, next);
    var getMethod = function(kind){
      if(!BUGGY && kind in proto)return proto[kind];
      switch(kind){
        case KEYS: return function keys(){ return new Constructor(this, kind); };
        case VALUES: return function values(){ return new Constructor(this, kind); };
      } return function entries(){ return new Constructor(this, kind); };
    };
    var TAG        = NAME + ' Iterator'
      , DEF_VALUES = DEFAULT == VALUES
      , VALUES_BUG = false
      , proto      = Base.prototype
      , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
      , $default   = $native || getMethod(DEFAULT)
      , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined
      , $anyNative = NAME == 'Array' ? proto.entries || $native : $native
      , methods, key, IteratorPrototype;
    // Fix native
    if($anyNative){
      IteratorPrototype = getPrototypeOf($anyNative.call(new Base));
      if(IteratorPrototype !== Object.prototype){
        // Set @@toStringTag to native iterators
        setToStringTag(IteratorPrototype, TAG, true);
        // fix for some old engines
        if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);
      }
    }
    // fix Array#{values, @@iterator}.name in V8 / FF
    if(DEF_VALUES && $native && $native.name !== VALUES){
      VALUES_BUG = true;
      $default = function values(){ return $native.call(this); };
    }
    // Define iterator
    if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){
      hide(proto, ITERATOR, $default);
    }
    // Plug for library
    Iterators[NAME] = $default;
    Iterators[TAG]  = returnThis;
    if(DEFAULT){
      methods = {
        values:  DEF_VALUES ? $default : getMethod(VALUES),
        keys:    IS_SET     ? $default : getMethod(KEYS),
        entries: $entries
      };
      if(FORCED)for(key in methods){
        if(!(key in proto))redefine(proto, key, methods[key]);
      } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
    }
    return methods;
  };
  });

  var require$$4$3 = (_iterDefine && typeof _iterDefine === 'object' && 'default' in _iterDefine ? _iterDefine['default'] : _iterDefine);

  var _iterStep = __commonjs(function (module) {
  module.exports = function(done, value){
    return {value: value, done: !!done};
  };
  });

  var require$$3$8 = (_iterStep && typeof _iterStep === 'object' && 'default' in _iterStep ? _iterStep['default'] : _iterStep);

  var _addToUnscopables = __commonjs(function (module) {
  module.exports = function(){ /* empty */ };
  });

  var require$$4$4 = (_addToUnscopables && typeof _addToUnscopables === 'object' && 'default' in _addToUnscopables ? _addToUnscopables['default'] : _addToUnscopables);

  var es6_array_iterator = __commonjs(function (module) {
  'use strict';
  var addToUnscopables = require$$4$4
    , step             = require$$3$8
    , Iterators        = require$$1$12
    , toIObject        = require$$1$7;

  // 22.1.3.4 Array.prototype.entries()
  // 22.1.3.13 Array.prototype.keys()
  // 22.1.3.29 Array.prototype.values()
  // 22.1.3.30 Array.prototype[@@iterator]()
  module.exports = require$$4$3(Array, 'Array', function(iterated, kind){
    this._t = toIObject(iterated); // target
    this._i = 0;                   // next index
    this._k = kind;                // kind
  // 22.1.5.2.1 %ArrayIteratorPrototype%.next()
  }, function(){
    var O     = this._t
      , kind  = this._k
      , index = this._i++;
    if(!O || index >= O.length){
      this._t = undefined;
      return step(1);
    }
    if(kind == 'keys'  )return step(0, index);
    if(kind == 'values')return step(0, O[index]);
    return step(0, [index, O[index]]);
  }, 'values');

  // argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
  Iterators.Arguments = Iterators.Array;

  addToUnscopables('keys');
  addToUnscopables('values');
  addToUnscopables('entries');
  });

  var web_dom_iterable = __commonjs(function (module) {
  var global        = require$$12$1
    , hide          = require$$10
    , Iterators     = require$$1$12
    , TO_STRING_TAG = require$$0$5('toStringTag');

  for(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){
    var NAME       = collections[i]
      , Collection = global[NAME]
      , proto      = Collection && Collection.prototype;
    if(proto && !proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);
    Iterators[NAME] = Iterators.Array;
  }
  });

  var _stringAt = __commonjs(function (module) {
  var toInteger = require$$1$5
    , defined   = require$$6;
  // true  -> String#at
  // false -> String#codePointAt
  module.exports = function(TO_STRING){
    return function(that, pos){
      var s = String(defined(that))
        , i = toInteger(pos)
        , l = s.length
        , a, b;
      if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
      a = s.charCodeAt(i);
      return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
        ? TO_STRING ? s.charAt(i) : a
        : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
    };
  };
  });

  var require$$1$14 = (_stringAt && typeof _stringAt === 'object' && 'default' in _stringAt ? _stringAt['default'] : _stringAt);

  var es6_string_iterator = __commonjs(function (module) {
  'use strict';
  var $at  = require$$1$14(true);

  // 21.1.3.27 String.prototype[@@iterator]()
  require$$4$3(String, 'String', function(iterated){
    this._t = String(iterated); // target
    this._i = 0;                // next index
  // 21.1.5.2.1 %StringIteratorPrototype%.next()
  }, function(){
    var O     = this._t
      , index = this._i
      , point;
    if(index >= O.length)return {value: undefined, done: true};
    point = $at(O, index);
    this._i += point.length;
    return {value: point, done: false};
  });
  });

  var iterator$1 = __commonjs(function (module) {
  module.exports = require$$0$4.f('iterator');
  });

  var require$$0$11 = (iterator$1 && typeof iterator$1 === 'object' && 'default' in iterator$1 ? iterator$1['default'] : iterator$1);

  var iterator = __commonjs(function (module) {
  module.exports = { "default": require$$0$11, __esModule: true };
  });

  var require$$1$11 = (iterator && typeof iterator === 'object' && 'default' in iterator ? iterator['default'] : iterator);

  var _typeof = __commonjs(function (module, exports) {
  "use strict";

  exports.__esModule = true;

  var _iterator = require$$1$11;

  var _iterator2 = _interopRequireDefault(_iterator);

  var _symbol = require$$0$1;

  var _symbol2 = _interopRequireDefault(_symbol);

  var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default ? "symbol" : typeof obj; };

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
    return typeof obj === "undefined" ? "undefined" : _typeof(obj);
  } : function (obj) {
    return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
  };
  });

  var require$$2$5 = (_typeof && typeof _typeof === 'object' && 'default' in _typeof ? _typeof['default'] : _typeof);

  var es6_object_create = __commonjs(function (module) {
  var $export = require$$11$1
  // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
  $export($export.S, 'Object', {create: require$$11});
  });

  var create$1 = __commonjs(function (module) {
  var $Object = require$$0$3.Object;
  module.exports = function create(P, D){
    return $Object.create(P, D);
  };
  });

  var require$$0$12 = (create$1 && typeof create$1 === 'object' && 'default' in create$1 ? create$1['default'] : create$1);

  var create = __commonjs(function (module) {
  module.exports = { "default": require$$0$12, __esModule: true };
  });

  var _Object$create = (create && typeof create === 'object' && 'default' in create ? create['default'] : create);

  var _setProto = __commonjs(function (module) {
  // Works with __proto__ only. Old v8 can't work with null proto objects.
  /* eslint-disable no-proto */
  var isObject = require$$2
    , anObject = require$$2$2;
  var check = function(O, proto){
    anObject(O);
    if(!isObject(proto) && proto !== null)throw TypeError(proto + ": can't set as prototype!");
  };
  module.exports = {
    set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
      function(test, buggy, set){
        try {
          set = require$$8$1(Function.call, require$$0$9.f(Object.prototype, '__proto__').set, 2);
          set(test, []);
          buggy = !(test instanceof Array);
        } catch(e){ buggy = true; }
        return function setPrototypeOf(O, proto){
          check(O, proto);
          if(buggy)O.__proto__ = proto;
          else set(O, proto);
          return O;
        };
      }({}, false) : undefined),
    check: check
  };
  });

  var require$$9$1 = (_setProto && typeof _setProto === 'object' && 'default' in _setProto ? _setProto['default'] : _setProto);

  var es6_object_setPrototypeOf = __commonjs(function (module) {
  // 19.1.3.19 Object.setPrototypeOf(O, proto)
  var $export = require$$11$1;
  $export($export.S, 'Object', {setPrototypeOf: require$$9$1.set});
  });

  var setPrototypeOf$1 = __commonjs(function (module) {
  module.exports = require$$0$3.Object.setPrototypeOf;
  });

  var require$$0$13 = (setPrototypeOf$1 && typeof setPrototypeOf$1 === 'object' && 'default' in setPrototypeOf$1 ? setPrototypeOf$1['default'] : setPrototypeOf$1);

  var setPrototypeOf = __commonjs(function (module) {
  module.exports = { "default": require$$0$13, __esModule: true };
  });

  var require$$4$5 = (setPrototypeOf && typeof setPrototypeOf === 'object' && 'default' in setPrototypeOf ? setPrototypeOf['default'] : setPrototypeOf);

  var _iterDetect = __commonjs(function (module) {
  var ITERATOR     = require$$0$5('iterator')
    , SAFE_CLOSING = false;

  try {
    var riter = [7][ITERATOR]();
    riter['return'] = function(){ SAFE_CLOSING = true; };
    Array.from(riter, function(){ throw 2; });
  } catch(e){ /* empty */ }

  module.exports = function(exec, skipClosing){
    if(!skipClosing && !SAFE_CLOSING)return false;
    var safe = false;
    try {
      var arr  = [7]
        , iter = arr[ITERATOR]();
      iter.next = function(){ return {done: safe = true}; };
      arr[ITERATOR] = function(){ return iter; };
      exec(arr);
    } catch(e){ /* empty */ }
    return safe;
  };
  });

  var require$$0$16 = (_iterDetect && typeof _iterDetect === 'object' && 'default' in _iterDetect ? _iterDetect['default'] : _iterDetect);

  var _setSpecies = __commonjs(function (module) {
  'use strict';
  var global      = require$$12$1
    , core        = require$$0$3
    , dP          = require$$12
    , DESCRIPTORS = require$$1
    , SPECIES     = require$$0$5('species');

  module.exports = function(KEY){
    var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY];
    if(DESCRIPTORS && C && !C[SPECIES])dP.f(C, SPECIES, {
      configurable: true,
      get: function(){ return this; }
    });
  };
  });

  var require$$2$6 = (_setSpecies && typeof _setSpecies === 'object' && 'default' in _setSpecies ? _setSpecies['default'] : _setSpecies);

  var _redefineAll = __commonjs(function (module) {
  var hide = require$$10;
  module.exports = function(target, src, safe){
    for(var key in src){
      if(safe && target[key])target[key] = src[key];
      else hide(target, key, src[key]);
    } return target;
  };
  });

  var require$$9$2 = (_redefineAll && typeof _redefineAll === 'object' && 'default' in _redefineAll ? _redefineAll['default'] : _redefineAll);

  var _invoke = __commonjs(function (module) {
  // fast apply, http://jsperf.lnkit.com/fast-apply/5
  module.exports = function(fn, args, that){
    var un = that === undefined;
    switch(args.length){
      case 0: return un ? fn()
                        : fn.call(that);
      case 1: return un ? fn(args[0])
                        : fn.call(that, args[0]);
      case 2: return un ? fn(args[0], args[1])
                        : fn.call(that, args[0], args[1]);
      case 3: return un ? fn(args[0], args[1], args[2])
                        : fn.call(that, args[0], args[1], args[2]);
      case 4: return un ? fn(args[0], args[1], args[2], args[3])
                        : fn.call(that, args[0], args[1], args[2], args[3]);
    } return              fn.apply(that, args);
  };
  });

  var require$$4$6 = (_invoke && typeof _invoke === 'object' && 'default' in _invoke ? _invoke['default'] : _invoke);

  var _task = __commonjs(function (module, exports, global) {
  var ctx                = require$$8$1
    , invoke             = require$$4$6
    , html               = require$$3$5
    , cel                = require$$2$1
    , global             = require$$12$1
    , process            = global.process
    , setTask            = global.setImmediate
    , clearTask          = global.clearImmediate
    , MessageChannel     = global.MessageChannel
    , counter            = 0
    , queue              = {}
    , ONREADYSTATECHANGE = 'onreadystatechange'
    , defer, channel, port;
  var run = function(){
    var id = +this;
    if(queue.hasOwnProperty(id)){
      var fn = queue[id];
      delete queue[id];
      fn();
    }
  };
  var listener = function(event){
    run.call(event.data);
  };
  // Node.js 0.9+ & IE10+ has setImmediate, otherwise:
  if(!setTask || !clearTask){
    setTask = function setImmediate(fn){
      var args = [], i = 1;
      while(arguments.length > i)args.push(arguments[i++]);
      queue[++counter] = function(){
        invoke(typeof fn == 'function' ? fn : Function(fn), args);
      };
      defer(counter);
      return counter;
    };
    clearTask = function clearImmediate(id){
      delete queue[id];
    };
    // Node.js 0.8-
    if(require$$1$8(process) == 'process'){
      defer = function(id){
        process.nextTick(ctx(run, id, 1));
      };
    // Browsers with MessageChannel, includes WebWorkers
    } else if(MessageChannel){
      channel = new MessageChannel;
      port    = channel.port2;
      channel.port1.onmessage = listener;
      defer = ctx(port.postMessage, port, 1);
    // Browsers with postMessage, skip WebWorkers
    // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
    } else if(global.addEventListener && typeof postMessage == 'function' && !global.importScripts){
      defer = function(id){
        global.postMessage(id + '', '*');
      };
      global.addEventListener('message', listener, false);
    // IE8-
    } else if(ONREADYSTATECHANGE in cel('script')){
      defer = function(id){
        html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function(){
          html.removeChild(this);
          run.call(id);
        };
      };
    // Rest old browsers
    } else {
      defer = function(id){
        setTimeout(ctx(run, id, 1), 0);
      };
    }
  }
  module.exports = {
    set:   setTask,
    clear: clearTask
  };
  });

  var require$$1$15 = (_task && typeof _task === 'object' && 'default' in _task ? _task['default'] : _task);

  var _microtask = __commonjs(function (module) {
  var global    = require$$12$1
    , macrotask = require$$1$15.set
    , Observer  = global.MutationObserver || global.WebKitMutationObserver
    , process   = global.process
    , Promise   = global.Promise
    , isNode    = require$$1$8(process) == 'process';

  module.exports = function(){
    var head, last, notify;

    var flush = function(){
      var parent, fn;
      if(isNode && (parent = process.domain))parent.exit();
      while(head){
        fn   = head.fn;
        head = head.next;
        try {
          fn();
        } catch(e){
          if(head)notify();
          else last = undefined;
          throw e;
        }
      } last = undefined;
      if(parent)parent.enter();
    };

    // Node.js
    if(isNode){
      notify = function(){
        process.nextTick(flush);
      };
    // browsers with MutationObserver
    } else if(Observer){
      var toggle = true
        , node   = document.createTextNode('');
      new Observer(flush).observe(node, {characterData: true}); // eslint-disable-line no-new
      notify = function(){
        node.data = toggle = !toggle;
      };
    // environments with maybe non-completely correct, but existent Promise
    } else if(Promise && Promise.resolve){
      var promise = Promise.resolve();
      notify = function(){
        promise.then(flush);
      };
    // for other environments - macrotask based on:
    // - setImmediate
    // - MessageChannel
    // - window.postMessag
    // - onreadystatechange
    // - setTimeout
    } else {
      notify = function(){
        // strange IE + webpack dev server bug - use .call(global)
        macrotask.call(global, flush);
      };
    }

    return function(fn){
      var task = {fn: fn, next: undefined};
      if(last)last.next = task;
      if(!head){
        head = task;
        notify();
      } last = task;
    };
  };
  });

  var require$$6$1 = (_microtask && typeof _microtask === 'object' && 'default' in _microtask ? _microtask['default'] : _microtask);

  var _speciesConstructor = __commonjs(function (module) {
  // 7.3.20 SpeciesConstructor(O, defaultConstructor)
  var anObject  = require$$2$2
    , aFunction = require$$1$10
    , SPECIES   = require$$0$5('species');
  module.exports = function(O, D){
    var C = anObject(O).constructor, S;
    return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
  };
  });

  var require$$8$2 = (_speciesConstructor && typeof _speciesConstructor === 'object' && 'default' in _speciesConstructor ? _speciesConstructor['default'] : _speciesConstructor);

  var _classof = __commonjs(function (module) {
  // getting tag from 19.1.3.6 Object.prototype.toString()
  var cof = require$$1$8
    , TAG = require$$0$5('toStringTag')
    // ES3 wrong here
    , ARG = cof(function(){ return arguments; }()) == 'Arguments';

  // fallback for IE11 Script Access Denied error
  var tryGet = function(it, key){
    try {
      return it[key];
    } catch(e){ /* empty */ }
  };

  module.exports = function(it){
    var O, T, B;
    return it === undefined ? 'Undefined' : it === null ? 'Null'
      // @@toStringTag case
      : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
      // builtinTag case
      : ARG ? cof(O)
      // ES3 arguments fallback
      : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
  };
  });

  var require$$1$17 = (_classof && typeof _classof === 'object' && 'default' in _classof ? _classof['default'] : _classof);

  var core_getIteratorMethod = __commonjs(function (module) {
  var classof   = require$$1$17
    , ITERATOR  = require$$0$5('iterator')
    , Iterators = require$$1$12;
  module.exports = require$$0$3.getIteratorMethod = function(it){
    if(it != undefined)return it[ITERATOR]
      || it['@@iterator']
      || Iterators[classof(it)];
  };
  });

  var require$$1$16 = (core_getIteratorMethod && typeof core_getIteratorMethod === 'object' && 'default' in core_getIteratorMethod ? core_getIteratorMethod['default'] : core_getIteratorMethod);

  var _isArrayIter = __commonjs(function (module) {
  // check on default Array iterator
  var Iterators  = require$$1$12
    , ITERATOR   = require$$0$5('iterator')
    , ArrayProto = Array.prototype;

  module.exports = function(it){
    return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
  };
  });

  var require$$3$9 = (_isArrayIter && typeof _isArrayIter === 'object' && 'default' in _isArrayIter ? _isArrayIter['default'] : _isArrayIter);

  var _iterCall = __commonjs(function (module) {
  // call something on iterator step with safe closing on error
  var anObject = require$$2$2;
  module.exports = function(iterator, fn, value, entries){
    try {
      return entries ? fn(anObject(value)[0], value[1]) : fn(value);
    // 7.4.6 IteratorClose(iterator, completion)
    } catch(e){
      var ret = iterator['return'];
      if(ret !== undefined)anObject(ret.call(iterator));
      throw e;
    }
  };
  });

  var require$$4$7 = (_iterCall && typeof _iterCall === 'object' && 'default' in _iterCall ? _iterCall['default'] : _iterCall);

  var _forOf = __commonjs(function (module) {
  var ctx         = require$$8$1
    , call        = require$$4$7
    , isArrayIter = require$$3$9
    , anObject    = require$$2$2
    , toLength    = require$$1$6
    , getIterFn   = require$$1$16
    , BREAK       = {}
    , RETURN      = {};
  var exports = module.exports = function(iterable, entries, fn, that, ITERATOR){
    var iterFn = ITERATOR ? function(){ return iterable; } : getIterFn(iterable)
      , f      = ctx(fn, that, entries ? 2 : 1)
      , index  = 0
      , length, step, iterator, result;
    if(typeof iterFn != 'function')throw TypeError(iterable + ' is not iterable!');
    // fast case for arrays with default iterator
    if(isArrayIter(iterFn))for(length = toLength(iterable.length); length > index; index++){
      result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
      if(result === BREAK || result === RETURN)return result;
    } else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done; ){
      result = call(iterator, f, step.value, entries);
      if(result === BREAK || result === RETURN)return result;
    }
  };
  exports.BREAK  = BREAK;
  exports.RETURN = RETURN;
  });

  var require$$5$1 = (_forOf && typeof _forOf === 'object' && 'default' in _forOf ? _forOf['default'] : _forOf);

  var _anInstance = __commonjs(function (module) {
  module.exports = function(it, Constructor, name, forbiddenField){
    if(!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)){
      throw TypeError(name + ': incorrect invocation!');
    } return it;
  };
  });

  var require$$7$1 = (_anInstance && typeof _anInstance === 'object' && 'default' in _anInstance ? _anInstance['default'] : _anInstance);

  var es6_promise = __commonjs(function (module, exports, global) {
  'use strict';
  var LIBRARY            = require$$19
    , global             = require$$12$1
    , ctx                = require$$8$1
    , classof            = require$$1$17
    , $export            = require$$11$1
    , isObject           = require$$2
    , anObject           = require$$2$2
    , aFunction          = require$$1$10
    , anInstance         = require$$7$1
    , forOf              = require$$5$1
    , setProto           = require$$9$1.set
    , speciesConstructor = require$$8$2
    , task               = require$$1$15.set
    , microtask          = require$$6$1()
    , PROMISE            = 'Promise'
    , TypeError          = global.TypeError
    , process            = global.process
    , $Promise           = global[PROMISE]
    , process            = global.process
    , isNode             = classof(process) == 'process'
    , empty              = function(){ /* empty */ }
    , Internal, GenericPromiseCapability, Wrapper;

  var USE_NATIVE = !!function(){
    try {
      // correct subclassing with @@species support
      var promise     = $Promise.resolve(1)
        , FakePromise = (promise.constructor = {})[require$$0$5('species')] = function(exec){ exec(empty, empty); };
      // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
      return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
    } catch(e){ /* empty */ }
  }();

  // helpers
  var sameConstructor = function(a, b){
    // with library wrapper special case
    return a === b || a === $Promise && b === Wrapper;
  };
  var isThenable = function(it){
    var then;
    return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
  };
  var newPromiseCapability = function(C){
    return sameConstructor($Promise, C)
      ? new PromiseCapability(C)
      : new GenericPromiseCapability(C);
  };
  var PromiseCapability = GenericPromiseCapability = function(C){
    var resolve, reject;
    this.promise = new C(function($$resolve, $$reject){
      if(resolve !== undefined || reject !== undefined)throw TypeError('Bad Promise constructor');
      resolve = $$resolve;
      reject  = $$reject;
    });
    this.resolve = aFunction(resolve);
    this.reject  = aFunction(reject);
  };
  var perform = function(exec){
    try {
      exec();
    } catch(e){
      return {error: e};
    }
  };
  var notify = function(promise, isReject){
    if(promise._n)return;
    promise._n = true;
    var chain = promise._c;
    microtask(function(){
      var value = promise._v
        , ok    = promise._s == 1
        , i     = 0;
      var run = function(reaction){
        var handler = ok ? reaction.ok : reaction.fail
          , resolve = reaction.resolve
          , reject  = reaction.reject
          , domain  = reaction.domain
          , result, then;
        try {
          if(handler){
            if(!ok){
              if(promise._h == 2)onHandleUnhandled(promise);
              promise._h = 1;
            }
            if(handler === true)result = value;
            else {
              if(domain)domain.enter();
              result = handler(value);
              if(domain)domain.exit();
            }
            if(result === reaction.promise){
              reject(TypeError('Promise-chain cycle'));
            } else if(then = isThenable(result)){
              then.call(result, resolve, reject);
            } else resolve(result);
          } else reject(value);
        } catch(e){
          reject(e);
        }
      };
      while(chain.length > i)run(chain[i++]); // variable length - can't use forEach
      promise._c = [];
      promise._n = false;
      if(isReject && !promise._h)onUnhandled(promise);
    });
  };
  var onUnhandled = function(promise){
    task.call(global, function(){
      var value = promise._v
        , abrupt, handler, console;
      if(isUnhandled(promise)){
        abrupt = perform(function(){
          if(isNode){
            process.emit('unhandledRejection', value, promise);
          } else if(handler = global.onunhandledrejection){
            handler({promise: promise, reason: value});
          } else if((console = global.console) && console.error){
            console.error('Unhandled promise rejection', value);
          }
        });
        // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
        promise._h = isNode || isUnhandled(promise) ? 2 : 1;
      } promise._a = undefined;
      if(abrupt)throw abrupt.error;
    });
  };
  var isUnhandled = function(promise){
    if(promise._h == 1)return false;
    var chain = promise._a || promise._c
      , i     = 0
      , reaction;
    while(chain.length > i){
      reaction = chain[i++];
      if(reaction.fail || !isUnhandled(reaction.promise))return false;
    } return true;
  };
  var onHandleUnhandled = function(promise){
    task.call(global, function(){
      var handler;
      if(isNode){
        process.emit('rejectionHandled', promise);
      } else if(handler = global.onrejectionhandled){
        handler({promise: promise, reason: promise._v});
      }
    });
  };
  var $reject = function(value){
    var promise = this;
    if(promise._d)return;
    promise._d = true;
    promise = promise._w || promise; // unwrap
    promise._v = value;
    promise._s = 2;
    if(!promise._a)promise._a = promise._c.slice();
    notify(promise, true);
  };
  var $resolve = function(value){
    var promise = this
      , then;
    if(promise._d)return;
    promise._d = true;
    promise = promise._w || promise; // unwrap
    try {
      if(promise === value)throw TypeError("Promise can't be resolved itself");
      if(then = isThenable(value)){
        microtask(function(){
          var wrapper = {_w: promise, _d: false}; // wrap
          try {
            then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
          } catch(e){
            $reject.call(wrapper, e);
          }
        });
      } else {
        promise._v = value;
        promise._s = 1;
        notify(promise, false);
      }
    } catch(e){
      $reject.call({_w: promise, _d: false}, e); // wrap
    }
  };

  // constructor polyfill
  if(!USE_NATIVE){
    // 25.4.3.1 Promise(executor)
    $Promise = function Promise(executor){
      anInstance(this, $Promise, PROMISE, '_h');
      aFunction(executor);
      Internal.call(this);
      try {
        executor(ctx($resolve, this, 1), ctx($reject, this, 1));
      } catch(err){
        $reject.call(this, err);
      }
    };
    Internal = function Promise(executor){
      this._c = [];             // <- awaiting reactions
      this._a = undefined;      // <- checked in isUnhandled reactions
      this._s = 0;              // <- state
      this._d = false;          // <- done
      this._v = undefined;      // <- value
      this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
      this._n = false;          // <- notify
    };
    Internal.prototype = require$$9$2($Promise.prototype, {
      // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
      then: function then(onFulfilled, onRejected){
        var reaction    = newPromiseCapability(speciesConstructor(this, $Promise));
        reaction.ok     = typeof onFulfilled == 'function' ? onFulfilled : true;
        reaction.fail   = typeof onRejected == 'function' && onRejected;
        reaction.domain = isNode ? process.domain : undefined;
        this._c.push(reaction);
        if(this._a)this._a.push(reaction);
        if(this._s)notify(this, false);
        return reaction.promise;
      },
      // 25.4.5.1 Promise.prototype.catch(onRejected)
      'catch': function(onRejected){
        return this.then(undefined, onRejected);
      }
    });
    PromiseCapability = function(){
      var promise  = new Internal;
      this.promise = promise;
      this.resolve = ctx($resolve, promise, 1);
      this.reject  = ctx($reject, promise, 1);
    };
  }

  $export($export.G + $export.W + $export.F * !USE_NATIVE, {Promise: $Promise});
  require$$3$6($Promise, PROMISE);
  require$$2$6(PROMISE);
  Wrapper = require$$0$3[PROMISE];

  // statics
  $export($export.S + $export.F * !USE_NATIVE, PROMISE, {
    // 25.4.4.5 Promise.reject(r)
    reject: function reject(r){
      var capability = newPromiseCapability(this)
        , $$reject   = capability.reject;
      $$reject(r);
      return capability.promise;
    }
  });
  $export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
    // 25.4.4.6 Promise.resolve(x)
    resolve: function resolve(x){
      // instanceof instead of internal slot check because we should fix it without replacement native Promise core
      if(x instanceof $Promise && sameConstructor(x.constructor, this))return x;
      var capability = newPromiseCapability(this)
        , $$resolve  = capability.resolve;
      $$resolve(x);
      return capability.promise;
    }
  });
  $export($export.S + $export.F * !(USE_NATIVE && require$$0$16(function(iter){
    $Promise.all(iter)['catch'](empty);
  })), PROMISE, {
    // 25.4.4.1 Promise.all(iterable)
    all: function all(iterable){
      var C          = this
        , capability = newPromiseCapability(C)
        , resolve    = capability.resolve
        , reject     = capability.reject;
      var abrupt = perform(function(){
        var values    = []
          , index     = 0
          , remaining = 1;
        forOf(iterable, false, function(promise){
          var $index        = index++
            , alreadyCalled = false;
          values.push(undefined);
          remaining++;
          C.resolve(promise).then(function(value){
            if(alreadyCalled)return;
            alreadyCalled  = true;
            values[$index] = value;
            --remaining || resolve(values);
          }, reject);
        });
        --remaining || resolve(values);
      });
      if(abrupt)reject(abrupt.error);
      return capability.promise;
    },
    // 25.4.4.4 Promise.race(iterable)
    race: function race(iterable){
      var C          = this
        , capability = newPromiseCapability(C)
        , reject     = capability.reject;
      var abrupt = perform(function(){
        forOf(iterable, false, function(promise){
          C.resolve(promise).then(capability.resolve, reject);
        });
      });
      if(abrupt)reject(abrupt.error);
      return capability.promise;
    }
  });
  });

  var promise$1 = __commonjs(function (module) {
  module.exports = require$$0$3.Promise;
  });

  var require$$0$15 = (promise$1 && typeof promise$1 === 'object' && 'default' in promise$1 ? promise$1['default'] : promise$1);

  var promise = __commonjs(function (module) {
  module.exports = { "default": require$$0$15, __esModule: true };
  });

  var require$$0$14 = (promise && typeof promise === 'object' && 'default' in promise ? promise['default'] : promise);

  var runtime = __commonjs(function (module, exports, global) {
  "use strict";

  var _promise = require$$0$14;

  var _promise2 = _interopRequireDefault(_promise);

  var _setPrototypeOf = require$$4$5;

  var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

  var _create = _Object$create;

  var _create2 = _interopRequireDefault(_create);

  var _typeof2 = require$$2$5;

  var _typeof3 = _interopRequireDefault(_typeof2);

  var _iterator = require$$1$11;

  var _iterator2 = _interopRequireDefault(_iterator);

  var _symbol = require$$0$1;

  var _symbol2 = _interopRequireDefault(_symbol);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * Copyright (c) 2014, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
   * additional grant of patent rights can be found in the PATENTS file in
   * the same directory.
   */

  !function (global) {
    "use strict";

    var hasOwn = Object.prototype.hasOwnProperty;
    var undefined; // More compressible than void 0.
    var iteratorSymbol = typeof _symbol2.default === "function" && _iterator2.default || "@@iterator";

    var inModule = (typeof module === "undefined" ? "undefined" : (0, _typeof3.default)(module)) === "object";
    var runtime = global.regeneratorRuntime;
    if (runtime) {
      if (inModule) {
        // If regeneratorRuntime is defined globally and we're in a module,
        // make the exports object identical to regeneratorRuntime.
        module.exports = runtime;
      }
      // Don't bother evaluating the rest of this file if the runtime was
      // already defined globally.
      return;
    }

    // Define the runtime globally (as expected by generated code) as either
    // module.exports (if we're in a module) or a new, empty object.
    runtime = global.regeneratorRuntime = inModule ? module.exports : {};

    function wrap(innerFn, outerFn, self, tryLocsList) {
      // If outerFn provided, then outerFn.prototype instanceof Generator.
      var generator = (0, _create2.default)((outerFn || Generator).prototype);
      var context = new Context(tryLocsList || []);

      // The ._invoke method unifies the implementations of the .next,
      // .throw, and .return methods.
      generator._invoke = makeInvokeMethod(innerFn, self, context);

      return generator;
    }
    runtime.wrap = wrap;

    // Try/catch helper to minimize deoptimizations. Returns a completion
    // record like context.tryEntries[i].completion. This interface could
    // have been (and was previously) designed to take a closure to be
    // invoked without arguments, but in all the cases we care about we
    // already have an existing method we want to call, so there's no need
    // to create a new function object. We can even get away with assuming
    // the method takes exactly one argument, since that happens to be true
    // in every case, so we don't have to touch the arguments object. The
    // only additional allocation required is the completion record, which
    // has a stable shape and so hopefully should be cheap to allocate.
    function tryCatch(fn, obj, arg) {
      try {
        return { type: "normal", arg: fn.call(obj, arg) };
      } catch (err) {
        return { type: "throw", arg: err };
      }
    }

    var GenStateSuspendedStart = "suspendedStart";
    var GenStateSuspendedYield = "suspendedYield";
    var GenStateExecuting = "executing";
    var GenStateCompleted = "completed";

    // Returning this object from the innerFn has the same effect as
    // breaking out of the dispatch switch statement.
    var ContinueSentinel = {};

    // Dummy constructor functions that we use as the .constructor and
    // .constructor.prototype properties for functions that return Generator
    // objects. For full spec compliance, you may wish to configure your
    // minifier not to mangle the names of these two functions.
    function Generator() {}
    function GeneratorFunction() {}
    function GeneratorFunctionPrototype() {}

    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;
    GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
    GeneratorFunctionPrototype.constructor = GeneratorFunction;
    GeneratorFunction.displayName = "GeneratorFunction";

    // Helper for defining the .next, .throw, and .return methods of the
    // Iterator interface in terms of a single ._invoke method.
    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function (method) {
        prototype[method] = function (arg) {
          return this._invoke(method, arg);
        };
      });
    }

    runtime.isGeneratorFunction = function (genFun) {
      var ctor = typeof genFun === "function" && genFun.constructor;
      return ctor ? ctor === GeneratorFunction ||
      // For the native GeneratorFunction constructor, the best we can
      // do is to check its .name property.
      (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
    };

    runtime.mark = function (genFun) {
      if (_setPrototypeOf2.default) {
        (0, _setPrototypeOf2.default)(genFun, GeneratorFunctionPrototype);
      } else {
        genFun.__proto__ = GeneratorFunctionPrototype;
      }
      genFun.prototype = (0, _create2.default)(Gp);
      return genFun;
    };

    // Within the body of any async function, `await x` is transformed to
    // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
    // `value instanceof AwaitArgument` to determine if the yielded value is
    // meant to be awaited. Some may consider the name of this method too
    // cutesy, but they are curmudgeons.
    runtime.awrap = function (arg) {
      return new AwaitArgument(arg);
    };

    function AwaitArgument(arg) {
      this.arg = arg;
    }

    function AsyncIterator(generator) {
      // This invoke function is written in a style that assumes some
      // calling function (or Promise) will handle exceptions.
      function invoke(method, arg) {
        var result = generator[method](arg);
        var value = result.value;
        return value instanceof AwaitArgument ? _promise2.default.resolve(value.arg).then(invokeNext, invokeThrow) : _promise2.default.resolve(value).then(function (unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          return result;
        });
      }

      if ((typeof process === "undefined" ? "undefined" : (0, _typeof3.default)(process)) === "object" && process.domain) {
        invoke = process.domain.bind(invoke);
      }

      var invokeNext = invoke.bind(generator, "next");
      var invokeThrow = invoke.bind(generator, "throw");
      var invokeReturn = invoke.bind(generator, "return");
      var previousPromise;

      function enqueue(method, arg) {
        function callInvokeWithMethodAndArg() {
          return invoke(method, arg);
        }

        return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(callInvokeWithMethodAndArg,
        // Avoid propagating failures to Promises returned by later
        // invocations of the iterator.
        callInvokeWithMethodAndArg) : new _promise2.default(function (resolve) {
          resolve(callInvokeWithMethodAndArg());
        });
      }

      // Define the unified helper method that is used to implement .next,
      // .throw, and .return (see defineIteratorMethods).
      this._invoke = enqueue;
    }

    defineIteratorMethods(AsyncIterator.prototype);

    // Note that simple async functions are implemented on top of
    // AsyncIterator objects; they just return a Promise for the value of
    // the final result produced by the iterator.
    runtime.async = function (innerFn, outerFn, self, tryLocsList) {
      var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));

      return runtime.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function (result) {
        return result.done ? result.value : iter.next();
      });
    };

    function makeInvokeMethod(innerFn, self, context) {
      var state = GenStateSuspendedStart;

      return function invoke(method, arg) {
        if (state === GenStateExecuting) {
          throw new Error("Generator is already running");
        }

        if (state === GenStateCompleted) {
          if (method === "throw") {
            throw arg;
          }

          // Be forgiving, per 25.3.3.3.3 of the spec:
          // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
          return doneResult();
        }

        while (true) {
          var delegate = context.delegate;
          if (delegate) {
            if (method === "return" || method === "throw" && delegate.iterator[method] === undefined) {
              // A return or throw (when the delegate iterator has no throw
              // method) always terminates the yield* loop.
              context.delegate = null;

              // If the delegate iterator has a return method, give it a
              // chance to clean up.
              var returnMethod = delegate.iterator["return"];
              if (returnMethod) {
                var record = tryCatch(returnMethod, delegate.iterator, arg);
                if (record.type === "throw") {
                  // If the return method threw an exception, let that
                  // exception prevail over the original return or throw.
                  method = "throw";
                  arg = record.arg;
                  continue;
                }
              }

              if (method === "return") {
                // Continue with the outer return, now that the delegate
                // iterator has been terminated.
                continue;
              }
            }

            var record = tryCatch(delegate.iterator[method], delegate.iterator, arg);

            if (record.type === "throw") {
              context.delegate = null;

              // Like returning generator.throw(uncaught), but without the
              // overhead of an extra function call.
              method = "throw";
              arg = record.arg;
              continue;
            }

            // Delegate generator ran and handled its own exceptions so
            // regardless of what the method was, we continue as if it is
            // "next" with an undefined arg.
            method = "next";
            arg = undefined;

            var info = record.arg;
            if (info.done) {
              context[delegate.resultName] = info.value;
              context.next = delegate.nextLoc;
            } else {
              state = GenStateSuspendedYield;
              return info;
            }

            context.delegate = null;
          }

          if (method === "next") {
            context._sent = arg;

            if (state === GenStateSuspendedYield) {
              context.sent = arg;
            } else {
              context.sent = undefined;
            }
          } else if (method === "throw") {
            if (state === GenStateSuspendedStart) {
              state = GenStateCompleted;
              throw arg;
            }

            if (context.dispatchException(arg)) {
              // If the dispatched exception was caught by a catch block,
              // then let that catch block handle the exception normally.
              method = "next";
              arg = undefined;
            }
          } else if (method === "return") {
            context.abrupt("return", arg);
          }

          state = GenStateExecuting;

          var record = tryCatch(innerFn, self, context);
          if (record.type === "normal") {
            // If an exception is thrown from innerFn, we leave state ===
            // GenStateExecuting and loop back for another invocation.
            state = context.done ? GenStateCompleted : GenStateSuspendedYield;

            var info = {
              value: record.arg,
              done: context.done
            };

            if (record.arg === ContinueSentinel) {
              if (context.delegate && method === "next") {
                // Deliberately forget the last sent value so that we don't
                // accidentally pass it on to the delegate.
                arg = undefined;
              }
            } else {
              return info;
            }
          } else if (record.type === "throw") {
            state = GenStateCompleted;
            // Dispatch the exception by looping back around to the
            // context.dispatchException(arg) call above.
            method = "throw";
            arg = record.arg;
          }
        }
      };
    }

    // Define Generator.prototype.{next,throw,return} in terms of the
    // unified ._invoke helper method.
    defineIteratorMethods(Gp);

    Gp[iteratorSymbol] = function () {
      return this;
    };

    Gp.toString = function () {
      return "[object Generator]";
    };

    function pushTryEntry(locs) {
      var entry = { tryLoc: locs[0] };

      if (1 in locs) {
        entry.catchLoc = locs[1];
      }

      if (2 in locs) {
        entry.finallyLoc = locs[2];
        entry.afterLoc = locs[3];
      }

      this.tryEntries.push(entry);
    }

    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal";
      delete record.arg;
      entry.completion = record;
    }

    function Context(tryLocsList) {
      // The root entry object (effectively a try statement without a catch
      // or a finally block) gives us a place to store values thrown from
      // locations where there is no enclosing try statement.
      this.tryEntries = [{ tryLoc: "root" }];
      tryLocsList.forEach(pushTryEntry, this);
      this.reset(true);
    }

    runtime.keys = function (object) {
      var keys = [];
      for (var key in object) {
        keys.push(key);
      }
      keys.reverse();

      // Rather than returning an object with a next method, we keep
      // things simple and return the next function itself.
      return function next() {
        while (keys.length) {
          var key = keys.pop();
          if (key in object) {
            next.value = key;
            next.done = false;
            return next;
          }
        }

        // To avoid creating an additional object, we just hang the .value
        // and .done properties off the next function object itself. This
        // also ensures that the minifier will not anonymize the function.
        next.done = true;
        return next;
      };
    };

    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];
        if (iteratorMethod) {
          return iteratorMethod.call(iterable);
        }

        if (typeof iterable.next === "function") {
          return iterable;
        }

        if (!isNaN(iterable.length)) {
          var i = -1,
              next = function next() {
            while (++i < iterable.length) {
              if (hasOwn.call(iterable, i)) {
                next.value = iterable[i];
                next.done = false;
                return next;
              }
            }

            next.value = undefined;
            next.done = true;

            return next;
          };

          return next.next = next;
        }
      }

      // Return an iterator with no values.
      return { next: doneResult };
    }
    runtime.values = values;

    function doneResult() {
      return { value: undefined, done: true };
    }

    Context.prototype = {
      constructor: Context,

      reset: function reset(skipTempReset) {
        this.prev = 0;
        this.next = 0;
        this.sent = undefined;
        this.done = false;
        this.delegate = null;

        this.tryEntries.forEach(resetTryEntry);

        if (!skipTempReset) {
          for (var name in this) {
            // Not sure about the optimal order of these conditions:
            if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
              this[name] = undefined;
            }
          }
        }
      },

      stop: function stop() {
        this.done = true;

        var rootEntry = this.tryEntries[0];
        var rootRecord = rootEntry.completion;
        if (rootRecord.type === "throw") {
          throw rootRecord.arg;
        }

        return this.rval;
      },

      dispatchException: function dispatchException(exception) {
        if (this.done) {
          throw exception;
        }

        var context = this;
        function handle(loc, caught) {
          record.type = "throw";
          record.arg = exception;
          context.next = loc;
          return !!caught;
        }

        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          var record = entry.completion;

          if (entry.tryLoc === "root") {
            // Exception thrown outside of any try block that could handle
            // it, so set the completion value of the entire function to
            // throw the exception.
            return handle("end");
          }

          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn.call(entry, "catchLoc");
            var hasFinally = hasOwn.call(entry, "finallyLoc");

            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              } else if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else if (hasCatch) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              }
            } else if (hasFinally) {
              if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else {
              throw new Error("try statement without catch or finally");
            }
          }
        }
      },

      abrupt: function abrupt(type, arg) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }

        if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
          // Ignore the finally entry if control is not jumping to a
          // location outside the try/catch block.
          finallyEntry = null;
        }

        var record = finallyEntry ? finallyEntry.completion : {};
        record.type = type;
        record.arg = arg;

        if (finallyEntry) {
          this.next = finallyEntry.finallyLoc;
        } else {
          this.complete(record);
        }

        return ContinueSentinel;
      },

      complete: function complete(record, afterLoc) {
        if (record.type === "throw") {
          throw record.arg;
        }

        if (record.type === "break" || record.type === "continue") {
          this.next = record.arg;
        } else if (record.type === "return") {
          this.rval = record.arg;
          this.next = "end";
        } else if (record.type === "normal" && afterLoc) {
          this.next = afterLoc;
        }
      },

      finish: function finish(finallyLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.finallyLoc === finallyLoc) {
            this.complete(entry.completion, entry.afterLoc);
            resetTryEntry(entry);
            return ContinueSentinel;
          }
        }
      },

      "catch": function _catch(tryLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;
            if (record.type === "throw") {
              var thrown = record.arg;
              resetTryEntry(entry);
            }
            return thrown;
          }
        }

        // The context.catch method must only be called with a location
        // argument that corresponds to a known catch block.
        throw new Error("illegal catch attempt");
      },

      delegateYield: function delegateYield(iterable, resultName, nextLoc) {
        this.delegate = {
          iterator: values(iterable),
          resultName: resultName,
          nextLoc: nextLoc
        };

        return ContinueSentinel;
      }
    };
  }(
  // Among the various tricks for obtaining a reference to the global
  // object, this seems to be the most reliable technique that does not
  // use indirect eval (which violates Content Security Policy).
  (typeof global === "undefined" ? "undefined" : (0, _typeof3.default)(global)) === "object" ? global : (typeof window === "undefined" ? "undefined" : (0, _typeof3.default)(window)) === "object" ? window : (typeof self === "undefined" ? "undefined" : (0, _typeof3.default)(self)) === "object" ? self : undefined);
  });

  var require$$0 = (runtime && typeof runtime === 'object' && 'default' in runtime ? runtime['default'] : runtime);

  var index = __commonjs(function (module, exports, global) {
  // This method of obtaining a reference to the global object needs to be
  // kept identical to the way it is obtained in runtime.js
  var g =
    typeof global === "object" ? global :
    typeof window === "object" ? window :
    typeof self === "object" ? self : __commonjs_global;

  // Use `getOwnPropertyNames` because not all browsers support calling
  // `hasOwnProperty` on the global `self` object in a worker. See #183.
  var hadRuntime = g.regeneratorRuntime &&
    Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;

  // Save the old regeneratorRuntime in case it needs to be restored later.
  var oldRuntime = hadRuntime && g.regeneratorRuntime;

  // Force reevalutation of runtime.js.
  g.regeneratorRuntime = undefined;

  module.exports = require$$0;

  if (hadRuntime) {
    // Restore the original runtime.
    g.regeneratorRuntime = oldRuntime;
  } else {
    // Remove the global property added by runtime.js.
    try {
      delete g.regeneratorRuntime;
    } catch(e) {
      g.regeneratorRuntime = undefined;
    }
  }

  module.exports = { "default": module.exports, __esModule: true };
  });

  var _regeneratorRuntime = (index && typeof index === 'object' && 'default' in index ? index['default'] : index);

  var _objectAssign = __commonjs(function (module) {
  'use strict';
  // 19.1.2.1 Object.assign(target, source, ...)
  var getKeys  = require$$5
    , gOPS     = require$$4$1
    , pIE      = require$$3$2
    , toObject = require$$2$4
    , IObject  = require$$3$4
    , $assign  = Object.assign;

  // should work with symbols and should have deterministic property order (V8 bug)
  module.exports = !$assign || require$$9(function(){
    var A = {}
      , B = {}
      , S = Symbol()
      , K = 'abcdefghijklmnopqrst';
    A[S] = 7;
    K.split('').forEach(function(k){ B[k] = k; });
    return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
  }) ? function assign(target, source){ // eslint-disable-line no-unused-vars
    var T     = toObject(target)
      , aLen  = arguments.length
      , index = 1
      , getSymbols = gOPS.f
      , isEnum     = pIE.f;
    while(aLen > index){
      var S      = IObject(arguments[index++])
        , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)
        , length = keys.length
        , j      = 0
        , key;
      while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];
    } return T;
  } : $assign;
  });

  var require$$0$18 = (_objectAssign && typeof _objectAssign === 'object' && 'default' in _objectAssign ? _objectAssign['default'] : _objectAssign);

  var es6_object_assign = __commonjs(function (module) {
  // 19.1.3.1 Object.assign(target, source)
  var $export = require$$11$1;

  $export($export.S + $export.F, 'Object', {assign: require$$0$18});
  });

  var assign$1 = __commonjs(function (module) {
  module.exports = require$$0$3.Object.assign;
  });

  var require$$0$17 = (assign$1 && typeof assign$1 === 'object' && 'default' in assign$1 ? assign$1['default'] : assign$1);

  var assign = __commonjs(function (module) {
  module.exports = { "default": require$$0$17, __esModule: true };
  });

  var _Object$assign = (assign && typeof assign === 'object' && 'default' in assign ? assign['default'] : assign);

  var asyncToGenerator = __commonjs(function (module, exports) {
  "use strict";

  exports.__esModule = true;

  var _promise = require$$0$14;

  var _promise2 = _interopRequireDefault(_promise);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  exports.default = function (fn) {
    return function () {
      var gen = fn.apply(this, arguments);
      return new _promise2.default(function (resolve, reject) {
        function step(key, arg) {
          try {
            var info = gen[key](arg);
            var value = info.value;
          } catch (error) {
            reject(error);
            return;
          }

          if (info.done) {
            resolve(value);
          } else {
            return _promise2.default.resolve(value).then(function (value) {
              return step("next", value);
            }, function (err) {
              return step("throw", err);
            });
          }
        }

        return step("next");
      });
    };
  };
  });

  var _asyncToGenerator = (asyncToGenerator && typeof asyncToGenerator === 'object' && 'default' in asyncToGenerator ? asyncToGenerator['default'] : asyncToGenerator);

  var core_getIterator = __commonjs(function (module) {
  var anObject = require$$2$2
    , get      = require$$1$16;
  module.exports = require$$0$3.getIterator = function(it){
    var iterFn = get(it);
    if(typeof iterFn != 'function')throw TypeError(it + ' is not iterable!');
    return anObject(iterFn.call(it));
  };
  });

  var require$$0$20 = (core_getIterator && typeof core_getIterator === 'object' && 'default' in core_getIterator ? core_getIterator['default'] : core_getIterator);

  var getIterator$1 = __commonjs(function (module) {
  module.exports = require$$0$20;
  });

  var require$$0$19 = (getIterator$1 && typeof getIterator$1 === 'object' && 'default' in getIterator$1 ? getIterator$1['default'] : getIterator$1);

  var getIterator = __commonjs(function (module) {
  module.exports = { "default": require$$0$19, __esModule: true };
  });

  var _getIterator = (getIterator && typeof getIterator === 'object' && 'default' in getIterator ? getIterator['default'] : getIterator);

  var _arrayFromIterable = __commonjs(function (module) {
  var forOf = require$$5$1;

  module.exports = function(iter, ITERATOR){
    var result = [];
    forOf(iter, false, result.push, result, ITERATOR);
    return result;
  };
  });

  var require$$0$23 = (_arrayFromIterable && typeof _arrayFromIterable === 'object' && 'default' in _arrayFromIterable ? _arrayFromIterable['default'] : _arrayFromIterable);

  var _collectionToJson = __commonjs(function (module) {
  // https://github.com/DavidBruant/Map-Set.prototype.toJSON
  var classof = require$$1$17
    , from    = require$$0$23;
  module.exports = function(NAME){
    return function toJSON(){
      if(classof(this) != NAME)throw TypeError(NAME + "#toJSON isn't generic");
      return from(this);
    };
  };
  });

  var require$$0$22 = (_collectionToJson && typeof _collectionToJson === 'object' && 'default' in _collectionToJson ? _collectionToJson['default'] : _collectionToJson);

  var es7_map_toJson = __commonjs(function (module) {
  // https://github.com/DavidBruant/Map-Set.prototype.toJSON
  var $export  = require$$11$1;

  $export($export.P + $export.R, 'Map', {toJSON: require$$0$22('Map')});
  });

  var _arraySpeciesConstructor = __commonjs(function (module) {
  var isObject = require$$2
    , isArray  = require$$1$9
    , SPECIES  = require$$0$5('species');

  module.exports = function(original){
    var C;
    if(isArray(original)){
      C = original.constructor;
      // cross-realm fallback
      if(typeof C == 'function' && (C === Array || isArray(C.prototype)))C = undefined;
      if(isObject(C)){
        C = C[SPECIES];
        if(C === null)C = undefined;
      }
    } return C === undefined ? Array : C;
  };
  });

  var require$$0$26 = (_arraySpeciesConstructor && typeof _arraySpeciesConstructor === 'object' && 'default' in _arraySpeciesConstructor ? _arraySpeciesConstructor['default'] : _arraySpeciesConstructor);

  var _arraySpeciesCreate = __commonjs(function (module) {
  // 9.4.2.3 ArraySpeciesCreate(originalArray, length)
  var speciesConstructor = require$$0$26;

  module.exports = function(original, length){
    return new (speciesConstructor(original))(length);
  };
  });

  var require$$0$25 = (_arraySpeciesCreate && typeof _arraySpeciesCreate === 'object' && 'default' in _arraySpeciesCreate ? _arraySpeciesCreate['default'] : _arraySpeciesCreate);

  var _arrayMethods = __commonjs(function (module) {
  // 0 -> Array#forEach
  // 1 -> Array#map
  // 2 -> Array#filter
  // 3 -> Array#some
  // 4 -> Array#every
  // 5 -> Array#find
  // 6 -> Array#findIndex
  var ctx      = require$$8$1
    , IObject  = require$$3$4
    , toObject = require$$2$4
    , toLength = require$$1$6
    , asc      = require$$0$25;
  module.exports = function(TYPE, $create){
    var IS_MAP        = TYPE == 1
      , IS_FILTER     = TYPE == 2
      , IS_SOME       = TYPE == 3
      , IS_EVERY      = TYPE == 4
      , IS_FIND_INDEX = TYPE == 6
      , NO_HOLES      = TYPE == 5 || IS_FIND_INDEX
      , create        = $create || asc;
    return function($this, callbackfn, that){
      var O      = toObject($this)
        , self   = IObject(O)
        , f      = ctx(callbackfn, that, 3)
        , length = toLength(self.length)
        , index  = 0
        , result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined
        , val, res;
      for(;length > index; index++)if(NO_HOLES || index in self){
        val = self[index];
        res = f(val, index, O);
        if(TYPE){
          if(IS_MAP)result[index] = res;            // map
          else if(res)switch(TYPE){
            case 3: return true;                    // some
            case 5: return val;                     // find
            case 6: return index;                   // findIndex
            case 2: result.push(val);               // filter
          } else if(IS_EVERY)return false;          // every
        }
      }
      return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
    };
  };
  });

  var require$$1$18 = (_arrayMethods && typeof _arrayMethods === 'object' && 'default' in _arrayMethods ? _arrayMethods['default'] : _arrayMethods);

  var _collection = __commonjs(function (module) {
  'use strict';
  var global         = require$$12$1
    , $export        = require$$11$1
    , meta           = require$$0$10
    , fails          = require$$9
    , hide           = require$$10
    , redefineAll    = require$$9$2
    , forOf          = require$$5$1
    , anInstance     = require$$7$1
    , isObject       = require$$2
    , setToStringTag = require$$3$6
    , dP             = require$$12.f
    , each           = require$$1$18(0)
    , DESCRIPTORS    = require$$1;

  module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK){
    var Base  = global[NAME]
      , C     = Base
      , ADDER = IS_MAP ? 'set' : 'add'
      , proto = C && C.prototype
      , O     = {};
    if(!DESCRIPTORS || typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function(){
      new C().entries().next();
    }))){
      // create collection constructor
      C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
      redefineAll(C.prototype, methods);
      meta.NEED = true;
    } else {
      C = wrapper(function(target, iterable){
        anInstance(target, C, NAME, '_c');
        target._c = new Base;
        if(iterable != undefined)forOf(iterable, IS_MAP, target[ADDER], target);
      });
      each('add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON'.split(','),function(KEY){
        var IS_ADDER = KEY == 'add' || KEY == 'set';
        if(KEY in proto && !(IS_WEAK && KEY == 'clear'))hide(C.prototype, KEY, function(a, b){
          anInstance(this, C, KEY);
          if(!IS_ADDER && IS_WEAK && !isObject(a))return KEY == 'get' ? undefined : false;
          var result = this._c[KEY](a === 0 ? 0 : a, b);
          return IS_ADDER ? this : result;
        });
      });
      if('size' in proto)dP(C.prototype, 'size', {
        get: function(){
          return this._c.size;
        }
      });
    }

    setToStringTag(C, NAME);

    O[NAME] = C;
    $export($export.G + $export.W + $export.F, O);

    if(!IS_WEAK)common.setStrong(C, NAME, IS_MAP);

    return C;
  };
  });

  var require$$0$24 = (_collection && typeof _collection === 'object' && 'default' in _collection ? _collection['default'] : _collection);

  var _collectionStrong = __commonjs(function (module) {
  'use strict';
  var dP          = require$$12.f
    , create      = require$$11
    , hide        = require$$10
    , redefineAll = require$$9$2
    , ctx         = require$$8$1
    , anInstance  = require$$7$1
    , defined     = require$$6
    , forOf       = require$$5$1
    , $iterDefine = require$$4$3
    , step        = require$$3$8
    , setSpecies  = require$$2$6
    , DESCRIPTORS = require$$1
    , fastKey     = require$$0$10.fastKey
    , SIZE        = DESCRIPTORS ? '_s' : 'size';

  var getEntry = function(that, key){
    // fast case
    var index = fastKey(key), entry;
    if(index !== 'F')return that._i[index];
    // frozen object case
    for(entry = that._f; entry; entry = entry.n){
      if(entry.k == key)return entry;
    }
  };

  module.exports = {
    getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
      var C = wrapper(function(that, iterable){
        anInstance(that, C, NAME, '_i');
        that._i = create(null); // index
        that._f = undefined;    // first entry
        that._l = undefined;    // last entry
        that[SIZE] = 0;         // size
        if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
      });
      redefineAll(C.prototype, {
        // 23.1.3.1 Map.prototype.clear()
        // 23.2.3.2 Set.prototype.clear()
        clear: function clear(){
          for(var that = this, data = that._i, entry = that._f; entry; entry = entry.n){
            entry.r = true;
            if(entry.p)entry.p = entry.p.n = undefined;
            delete data[entry.i];
          }
          that._f = that._l = undefined;
          that[SIZE] = 0;
        },
        // 23.1.3.3 Map.prototype.delete(key)
        // 23.2.3.4 Set.prototype.delete(value)
        'delete': function(key){
          var that  = this
            , entry = getEntry(that, key);
          if(entry){
            var next = entry.n
              , prev = entry.p;
            delete that._i[entry.i];
            entry.r = true;
            if(prev)prev.n = next;
            if(next)next.p = prev;
            if(that._f == entry)that._f = next;
            if(that._l == entry)that._l = prev;
            that[SIZE]--;
          } return !!entry;
        },
        // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
        // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
        forEach: function forEach(callbackfn /*, that = undefined */){
          anInstance(this, C, 'forEach');
          var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3)
            , entry;
          while(entry = entry ? entry.n : this._f){
            f(entry.v, entry.k, this);
            // revert to the last existing entry
            while(entry && entry.r)entry = entry.p;
          }
        },
        // 23.1.3.7 Map.prototype.has(key)
        // 23.2.3.7 Set.prototype.has(value)
        has: function has(key){
          return !!getEntry(this, key);
        }
      });
      if(DESCRIPTORS)dP(C.prototype, 'size', {
        get: function(){
          return defined(this[SIZE]);
        }
      });
      return C;
    },
    def: function(that, key, value){
      var entry = getEntry(that, key)
        , prev, index;
      // change existing entry
      if(entry){
        entry.v = value;
      // create new entry
      } else {
        that._l = entry = {
          i: index = fastKey(key, true), // <- index
          k: key,                        // <- key
          v: value,                      // <- value
          p: prev = that._l,             // <- previous entry
          n: undefined,                  // <- next entry
          r: false                       // <- removed
        };
        if(!that._f)that._f = entry;
        if(prev)prev.n = entry;
        that[SIZE]++;
        // add to index
        if(index !== 'F')that._i[index] = entry;
      } return that;
    },
    getEntry: getEntry,
    setStrong: function(C, NAME, IS_MAP){
      // add .keys, .values, .entries, [@@iterator]
      // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
      $iterDefine(C, NAME, function(iterated, kind){
        this._t = iterated;  // target
        this._k = kind;      // kind
        this._l = undefined; // previous
      }, function(){
        var that  = this
          , kind  = that._k
          , entry = that._l;
        // revert to the last existing entry
        while(entry && entry.r)entry = entry.p;
        // get next entry
        if(!that._t || !(that._l = entry = entry ? entry.n : that._t._f)){
          // or finish the iteration
          that._t = undefined;
          return step(1);
        }
        // return step by kind
        if(kind == 'keys'  )return step(0, entry.k);
        if(kind == 'values')return step(0, entry.v);
        return step(0, [entry.k, entry.v]);
      }, IS_MAP ? 'entries' : 'values' , !IS_MAP, true);

      // add [@@species], 23.1.2.2, 23.2.2.2
      setSpecies(NAME);
    }
  };
  });

  var require$$1$19 = (_collectionStrong && typeof _collectionStrong === 'object' && 'default' in _collectionStrong ? _collectionStrong['default'] : _collectionStrong);

  var es6_map = __commonjs(function (module) {
  'use strict';
  var strong = require$$1$19;

  // 23.1 Map Objects
  module.exports = require$$0$24('Map', function(get){
    return function Map(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
  }, {
    // 23.1.3.6 Map.prototype.get(key)
    get: function get(key){
      var entry = strong.getEntry(this, key);
      return entry && entry.v;
    },
    // 23.1.3.9 Map.prototype.set(key, value)
    set: function set(key, value){
      return strong.def(this, key === 0 ? 0 : key, value);
    }
  }, strong, true);
  });

  var map$1 = __commonjs(function (module) {
  module.exports = require$$0$3.Map;
  });

  var require$$0$21 = (map$1 && typeof map$1 === 'object' && 'default' in map$1 ? map$1['default'] : map$1);

  var map = __commonjs(function (module) {
  module.exports = { "default": require$$0$21, __esModule: true };
  });

  var _Map = (map && typeof map === 'object' && 'default' in map ? map['default'] : map);

  var index$3 = __commonjs(function (module) {
  module.exports = Array.isArray || function (arr) {
    return Object.prototype.toString.call(arr) == '[object Array]';
  };
  });

  var require$$0$27 = (index$3 && typeof index$3 === 'object' && 'default' in index$3 ? index$3['default'] : index$3);

  var index$2 = __commonjs(function (module) {
  var isarray = require$$0$27

  /**
   * Expose `pathToRegexp`.
   */
  module.exports = pathToRegexp
  module.exports.parse = parse
  module.exports.compile = compile
  module.exports.tokensToFunction = tokensToFunction
  module.exports.tokensToRegExp = tokensToRegExp

  /**
   * The main path matching regexp utility.
   *
   * @type {RegExp}
   */
  var PATH_REGEXP = new RegExp([
    // Match escaped characters that would otherwise appear in future matches.
    // This allows the user to escape special characters that won't transform.
    '(\\\\.)',
    // Match Express-style parameters and un-named parameters with a prefix
    // and optional suffixes. Matches appear as:
    //
    // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
    // "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
    // "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
    '([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^()])+)\\))?|\\(((?:\\\\.|[^()])+)\\))([+*?])?|(\\*))'
  ].join('|'), 'g')

  /**
   * Parse a string for the raw tokens.
   *
   * @param  {string} str
   * @return {!Array}
   */
  function parse (str) {
    var tokens = []
    var key = 0
    var index = 0
    var path = ''
    var res

    while ((res = PATH_REGEXP.exec(str)) != null) {
      var m = res[0]
      var escaped = res[1]
      var offset = res.index
      path += str.slice(index, offset)
      index = offset + m.length

      // Ignore already escaped sequences.
      if (escaped) {
        path += escaped[1]
        continue
      }

      var next = str[index]
      var prefix = res[2]
      var name = res[3]
      var capture = res[4]
      var group = res[5]
      var modifier = res[6]
      var asterisk = res[7]

      // Only use the prefix when followed by another path segment.
      if (prefix != null && next != null && next !== prefix) {
        path += prefix
        prefix = null
      }

      // Push the current path onto the tokens.
      if (path) {
        tokens.push(path)
        path = ''
      }

      var repeat = modifier === '+' || modifier === '*'
      var optional = modifier === '?' || modifier === '*'
      var delimiter = res[2] || '/'
      var pattern = capture || group || (asterisk ? '.*' : '[^' + delimiter + ']+?')

      tokens.push({
        name: name || key++,
        prefix: prefix || '',
        delimiter: delimiter,
        optional: optional,
        repeat: repeat,
        pattern: escapeGroup(pattern)
      })
    }

    // Match any characters still remaining.
    if (index < str.length) {
      path += str.substr(index)
    }

    // If the path exists, push it onto the end.
    if (path) {
      tokens.push(path)
    }

    return tokens
  }

  /**
   * Compile a string to a template function for the path.
   *
   * @param  {string}             str
   * @return {!function(Object=, Object=)}
   */
  function compile (str) {
    return tokensToFunction(parse(str))
  }

  /**
   * Encode characters for segment that could cause trouble for parsing.
   *
   * @param  {string}
   * @return {string}
   */
  function encodeURIComponentPretty (str) {
    return encodeURI(str).replace(/[/?#'"]/g, function (c) {
      return '%' + c.charCodeAt(0).toString(16).toUpperCase()
    })
  }

  /**
   * Expose a method for transforming tokens into the path function.
   */
  function tokensToFunction (tokens) {
    // Compile all the tokens into regexps.
    var matches = new Array(tokens.length)

    // Compile all the patterns before compilation.
    for (var i = 0; i < tokens.length; i++) {
      if (typeof tokens[i] === 'object') {
        matches[i] = new RegExp('^' + tokens[i].pattern + '$')
      }
    }

    return function (obj, opts) {
      var path = ''
      var data = obj || {}
      var options = opts || {}
      var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent

      for (var i = 0; i < tokens.length; i++) {
        var token = tokens[i]

        if (typeof token === 'string') {
          path += token

          continue
        }

        var value = data[token.name]
        var segment

        if (value == null) {
          if (token.optional) {
            continue
          } else {
            throw new TypeError('Expected "' + token.name + '" to be defined')
          }
        }

        if (isarray(value)) {
          if (!token.repeat) {
            throw new TypeError('Expected "' + token.name + '" to not repeat, but received "' + value + '"')
          }

          if (value.length === 0) {
            if (token.optional) {
              continue
            } else {
              throw new TypeError('Expected "' + token.name + '" to not be empty')
            }
          }

          for (var j = 0; j < value.length; j++) {
            segment = encode(value[j])

            if (!matches[i].test(segment)) {
              throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"')
            }

            path += (j === 0 ? token.prefix : token.delimiter) + segment
          }

          continue
        }

        segment = encode(value)

        if (!matches[i].test(segment)) {
          throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"')
        }

        path += token.prefix + segment
      }

      return path
    }
  }

  /**
   * Escape a regular expression string.
   *
   * @param  {string} str
   * @return {string}
   */
  function escapeString (str) {
    return str.replace(/([.+*?=^!:${}()[\]|\/])/g, '\\$1')
  }

  /**
   * Escape the capturing group by escaping special characters and meaning.
   *
   * @param  {string} group
   * @return {string}
   */
  function escapeGroup (group) {
    return group.replace(/([=!:$\/()])/g, '\\$1')
  }

  /**
   * Attach the keys as a property of the regexp.
   *
   * @param  {!RegExp} re
   * @param  {Array}   keys
   * @return {!RegExp}
   */
  function attachKeys (re, keys) {
    re.keys = keys
    return re
  }

  /**
   * Get the flags for a regexp from the options.
   *
   * @param  {Object} options
   * @return {string}
   */
  function flags (options) {
    return options.sensitive ? '' : 'i'
  }

  /**
   * Pull out keys from a regexp.
   *
   * @param  {!RegExp} path
   * @param  {!Array}  keys
   * @return {!RegExp}
   */
  function regexpToRegexp (path, keys) {
    // Use a negative lookahead to match only capturing groups.
    var groups = path.source.match(/\((?!\?)/g)

    if (groups) {
      for (var i = 0; i < groups.length; i++) {
        keys.push({
          name: i,
          prefix: null,
          delimiter: null,
          optional: false,
          repeat: false,
          pattern: null
        })
      }
    }

    return attachKeys(path, keys)
  }

  /**
   * Transform an array into a regexp.
   *
   * @param  {!Array}  path
   * @param  {Array}   keys
   * @param  {!Object} options
   * @return {!RegExp}
   */
  function arrayToRegexp (path, keys, options) {
    var parts = []

    for (var i = 0; i < path.length; i++) {
      parts.push(pathToRegexp(path[i], keys, options).source)
    }

    var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options))

    return attachKeys(regexp, keys)
  }

  /**
   * Create a path regexp from string input.
   *
   * @param  {string}  path
   * @param  {!Array}  keys
   * @param  {!Object} options
   * @return {!RegExp}
   */
  function stringToRegexp (path, keys, options) {
    var tokens = parse(path)
    var re = tokensToRegExp(tokens, options)

    // Attach keys back to the regexp.
    for (var i = 0; i < tokens.length; i++) {
      if (typeof tokens[i] !== 'string') {
        keys.push(tokens[i])
      }
    }

    return attachKeys(re, keys)
  }

  /**
   * Expose a function for taking tokens and returning a RegExp.
   *
   * @param  {!Array}  tokens
   * @param  {Object=} options
   * @return {!RegExp}
   */
  function tokensToRegExp (tokens, options) {
    options = options || {}

    var strict = options.strict
    var end = options.end !== false
    var route = ''
    var lastToken = tokens[tokens.length - 1]
    var endsWithSlash = typeof lastToken === 'string' && /\/$/.test(lastToken)

    // Iterate over the tokens and create our regexp string.
    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i]

      if (typeof token === 'string') {
        route += escapeString(token)
      } else {
        var prefix = escapeString(token.prefix)
        var capture = token.pattern

        if (token.repeat) {
          capture += '(?:' + prefix + capture + ')*'
        }

        if (token.optional) {
          if (prefix) {
            capture = '(?:' + prefix + '(' + capture + '))?'
          } else {
            capture = '(' + capture + ')?'
          }
        } else {
          capture = prefix + '(' + capture + ')'
        }

        route += capture
      }
    }

    // In non-strict mode we allow a slash at the end of match. If the path to
    // match already ends with a slash, we remove it for consistency. The slash
    // is valid at the end of a path match, not in the middle. This is important
    // in non-ending mode, where "/test/" shouldn't match "/test//route".
    if (!strict) {
      route = (endsWithSlash ? route.slice(0, -2) : route) + '(?:\\/(?=$))?'
    }

    if (end) {
      route += '$'
    } else {
      // In non-ending mode, we need the capturing groups to match as much as
      // possible by using a positive lookahead to the end or next path segment.
      route += strict && endsWithSlash ? '' : '(?=\\/|$)'
    }

    return new RegExp('^' + route, flags(options))
  }

  /**
   * Normalize the given path string, returning a regular expression.
   *
   * An empty array can be passed in for the keys, which will hold the
   * placeholder key descriptions. For example, using `/user/:id`, `keys` will
   * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
   *
   * @param  {(string|RegExp|Array)} path
   * @param  {(Array|Object)=}       keys
   * @param  {Object=}               options
   * @return {!RegExp}
   */
  function pathToRegexp (path, keys, options) {
    keys = keys || []

    if (!isarray(keys)) {
      options = /** @type {!Object} */ (keys)
      keys = []
    } else if (!options) {
      options = {}
    }

    if (path instanceof RegExp) {
      return regexpToRegexp(path, /** @type {!Array} */ (keys))
    }

    if (isarray(path)) {
      return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)
    }

    return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)
  }
  });

  var toRegExp = (index$2 && typeof index$2 === 'object' && 'default' in index$2 ? index$2['default'] : index$2);

  var cache = new _Map();

  function decodeParam(val) {
    if (!(typeof val === 'string' || val.length === 0)) {
      return val;
    }

    try {
      return decodeURIComponent(val);
    } catch (err) {
      if (err instanceof URIError) {
        err.message = 'Failed to decode param \'' + val + '\'';
        err.status = 400;
      }

      throw err;
    }
  }

  function matchPathBase(end, routePath, urlPath) {
    var key = routePath + '|' + end;
    var regexp = cache.get(key);

    if (!regexp) {
      var keys = [];
      regexp = { pattern: toRegExp(routePath, keys, { end: end }), keys: keys };
      cache.set(key, regexp);
    }

    var m = regexp.pattern.exec(urlPath);

    if (!m) {
      return null;
    }

    var params = _Object$create(null);
    var path = m[0];

    for (var i = 1; i < m.length; i++) {
      params[regexp.keys[i - 1].name] = m[i] !== undefined ? decodeParam(m[i]) : undefined;
    }

    return { path: path === '' ? '/' : path, keys: regexp.keys.slice(), params: params };
  }

  var matchPath = matchPathBase.bind(undefined, true);
  var matchBasePath = matchPathBase.bind(undefined, false);

  var _marked = [matchRoute].map(_regeneratorRuntime.mark);

  function matchRoute(route, baseUrl, path) {
    var match, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, childRoute, newPath;

    return _regeneratorRuntime.wrap(function matchRoute$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            match = void 0;

            if (route.children) {
              _context.next = 6;
              break;
            }

            match = matchPath(route.path, path);

            if (!match) {
              _context.next = 6;
              break;
            }

            _context.next = 6;
            return {
              route: route,
              baseUrl: baseUrl,
              path: match.path,
              keys: match.keys,
              params: match.params
            };

          case 6:
            if (!route.children) {
              _context.next = 37;
              break;
            }

            match = matchBasePath(route.path, path);

            if (!match) {
              _context.next = 37;
              break;
            }

            _context.next = 11;
            return {
              route: route,
              baseUrl: baseUrl,
              path: match.path,
              keys: match.keys,
              params: match.params
            };

          case 11:
            _iteratorNormalCompletion = true;
            _didIteratorError = false;
            _iteratorError = undefined;
            _context.prev = 14;
            _iterator = _getIterator(route.children);

          case 16:
            if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
              _context.next = 23;
              break;
            }

            childRoute = _step.value;
            newPath = path.substr(match.path.length);
            return _context.delegateYield(matchRoute(childRoute, baseUrl + (match.path === '/' ? '' : match.path), newPath.startsWith('/') ? newPath : '/' + newPath), 't0', 20);

          case 20:
            _iteratorNormalCompletion = true;
            _context.next = 16;
            break;

          case 23:
            _context.next = 29;
            break;

          case 25:
            _context.prev = 25;
            _context.t1 = _context['catch'](14);
            _didIteratorError = true;
            _iteratorError = _context.t1;

          case 29:
            _context.prev = 29;
            _context.prev = 30;

            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }

          case 32:
            _context.prev = 32;

            if (!_didIteratorError) {
              _context.next = 35;
              break;
            }

            throw _iteratorError;

          case 35:
            return _context.finish(32);

          case 36:
            return _context.finish(29);

          case 37:
          case 'end':
            return _context.stop();
        }
      }
    }, _marked[0], this, [[14, 25, 29, 37], [30,, 32, 36]]);
  }

  var resolve = function () {
    var ref = _asyncToGenerator(_regeneratorRuntime.mark(function _callee2(routes, pathOrContext) {
      var next = function () {
        var ref = _asyncToGenerator(_regeneratorRuntime.mark(function _callee() {
          var _match$next, newContext;

          return _regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _match$next = match.next();
                  value = _match$next.value;
                  done = _match$next.done;

                  if (!(value && !done)) {
                    _context.next = 23;
                    break;
                  }

                  newContext = _Object$assign({}, context, value);

                  if (!value.route.action) {
                    _context.next = 23;
                    break;
                  }

                  if (!errorRoute) {
                    _context.next = 20;
                    break;
                  }

                  _context.prev = 7;
                  _context.next = 10;
                  return value.route.action(newContext, newContext.params);

                case 10:
                  return _context.abrupt('return', _context.sent);

                case 13:
                  _context.prev = 13;
                  _context.t0 = _context['catch'](7);

                  _context.t0.status = _context.t0.status || 500;
                  newContext.error = _context.t0;
                  return _context.abrupt('return', errorRoute.action(newContext, newContext.params));

                case 18:
                  _context.next = 23;
                  break;

                case 20:
                  _context.next = 22;
                  return value.route.action(newContext, newContext.params);

                case 22:
                  return _context.abrupt('return', _context.sent);

                case 23:
                  return _context.abrupt('return', undefined);

                case 24:
                case 'end':
                  return _context.stop();
              }
            }
          }, _callee, this, [[7, 13]]);
        }));

        return function next() {
          return ref.apply(this, arguments);
        };
      }();

      var context, root, result, value, done, errorRoute, match;
      return _regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              context = typeof pathOrContext === 'string' || pathOrContext instanceof String ? { path: pathOrContext } : pathOrContext;
              root = Array.isArray(routes) ? { path: '/', children: routes } : routes;
              result = void 0;
              value = void 0;
              done = false;
              errorRoute = root.children && root.children.find(function (x) {
                return x.path === '/error';
              });
              match = matchRoute(root, '', context.path);


              context.next = next;
              context.end = function (data) {
                result = data;done = true;
              };

            case 9:
              if (done) {
                _context2.next = 17;
                break;
              }

              _context2.next = 12;
              return next();

            case 12:
              result = _context2.sent;

              if (!(result !== undefined)) {
                _context2.next = 15;
                break;
              }

              return _context2.abrupt('break', 17);

            case 15:
              _context2.next = 9;
              break;

            case 17:
              if (!(result === undefined && errorRoute)) {
                _context2.next = 21;
                break;
              }

              context.error = new Error('Not found');
              context.error.status = 404;
              return _context2.abrupt('return', errorRoute.action(context, {}));

            case 21:
              return _context2.abrupt('return', result);

            case 22:
            case 'end':
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    return function resolve(_x, _x2) {
      return ref.apply(this, arguments);
    };
  }();

  var main = { resolve: resolve, match: resolve /* alias */ };

  exports.resolve = resolve;
  exports.match = resolve;
  exports['default'] = main;

}));
//# sourceMappingURL=universal-router.js.map